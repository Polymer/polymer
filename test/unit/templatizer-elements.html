<dom-module id="x-host">
  <template>

    <x-templatizer obj="{{objA}}" prop="{{propA}}" id="templatizerA">
      <template>
        <x-child on-tap="handleTap" id="childA"
          outer-prop="{{outerProp}}"
          outer-obj="{{outerObj}}"
          outer-obj-prop="{{outerObj.prop}}"
          prop="{{prop}}"
          obj="{{obj}}"
          obj-prop="{{obj.prop}}"
          conflict="{{outerInnerConflict.prop}}"
          computed-from-literal="{{computeFromLiteral(33, prop)}}"
        ></x-child>
      </template>
    </x-templatizer>

    <x-templatizer prop="prop-a" name="templatizerB">
      <template>
        <x-child id="childB" computed-from-literal="{{computeFromLiteral(33, prop)}}"></x-child>
      </template>
    </x-templatizer>

  </template>
</dom-module>

<script>

  const templatizer = new Polymer.Templatizer();

  Polymer({
    is: 'x-child',
    properties: {
      outerProp: {
        notify: true
      },
      outerObj: {
        notify: true
      },
      outerObjProp: {
        notify: true
      },
      prop: {
        notify: true
      },
      obj: {
        notify: true
      },
      objProp: {
        notify: true
      },
      outerInnerConflict: {
        notify: true
      }
    },
    observers: [
      'objChanged(obj.*)',
      'outerObjChanged(outerObj.*)'
    ],
    objChanged: function() {},
    outerObjChanged: function() {}
  });

  Polymer({
    is: 'x-templatizer',
    properties: {
      obj: {
        notify: true
      },
      prop: {
        notify: true,
        observer: 'propChanged'
      }
    },
    observers: [
      'objChanged(obj.*)'
    ],
    propChanged: function(value) {
      if (this.instance) {
        this.instance.forwardProperty('prop', value);
        this.instance.flushProperties();
      }
    },
    objChanged: function(info) {
      if (this.instance) {
        this.instance.forwardProperty(info.path, info.value);
        this.instance.flushProperties();
      }
    },
    go: function(withProps) {
      var template = Polymer.dom(this).querySelector('template');
      template.host = this;
      var ctor = templatizer.templatize(template, {
        instanceProps: {
          obj: true,
          prop: true,
          outerInnerConflict: true
        },
        fwdHostPropToInstance: function(template, prop, value) {
          if (template.host.instance) {
            template.host.instance.forwardProperty(prop, value, template);
          }
        },
        fwdInstancePropToHost: function(inst, prop, value) {
          // notify path on host (set won't work since it dirty checks)
          inst.__template.host.notifyPath(prop, value);
        }
      });
      this.instance = new ctor(this,
        withProps ? {
          obj: this.obj,
          prop: this.prop,
          outerInnerConflict: {
            prop: 'bar'
          }
        } : null);
      var parent = Polymer.dom(this).parentNode;
      Polymer.dom(parent).appendChild(this.instance.root);
    }
  });


  Polymer({
    is: 'x-host',
    properties: {
      outerProp: {
        value: 'outerProp'
      },
      outerObj: {
        value: function() {
          return { prop: 'outerObj.prop' };
        }
      },
      propA: {
        value: 'prop-a'
      },
      objA: {
        value: function() {
          return { prop: 'objA.prop' };
        }
      },
      propB: {
        value: 'prop-b'
      },
      objB: {
        value: function() {
          return { prop: 'objB.prop' };
        }
      },
      outerInnerConflict: {
        value: function() {
          return { prop: 'conflict' };
        }
      }
    },
    observers: [
      'outerObjChanged(outerObj.*)',
      'objAChanged(objA.*)',
      'objBChanged(objB.*)'
    ],
    created: function() {
      this.handleTap = sinon.spy();
    },
    outerObjChanged: function() {},
    objAChanged: function() {},
    objBChanged: function() {},
    computeFromLiteral: function(literal, prop) { return literal + '-' + prop }
  });

</script>

