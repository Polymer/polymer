<!--
/*
 * Copyright 2012 The Toolkitchen Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
-->
<element name="g-overlay" attributes="opened, timeout" 
         handlers="click: clickHandler, keydown: keydownHandler,
         webkitAniamtionEnd: finishAnimate, webkitTransitionEnd: finishAnimate">
<link rel="components" href="g-component.html">
<link rel="stylesheet" href="css/g-overlay.css">
<template>
	<content></content>
</template>
<script>
  // TODO(sorvell): promote this if it becomes a pattern
  var setBooleanAttribute = function(inNode, inName, inValue) {
    inNode[inValue ? 'setAttribute' : 'removeAttribute'](inName, '');
  };
  
  // TODO(sorvell): is there a more new-fangled way to do this?
  var makeFocusable = function(inNode) {
    if (!inNode.hasAttribute('tabIndex')) {
      inNode.setAttribute('tabIndex', -1);
    }
  }
  
  /**
   * The overlay component is hidden by default and can be opened to display
   * its content. It's common to animate an overlay opened and closed. This 
   * can be achieved by styling the overlay node via the `opened` and
   * `animating` attributes.
  */
  this.component({
    shadowRootCreated: function() {
      this.hidden = true;
    },
    created: function() {
      makeFocusable(this);
    },
    prototype: {
      //* Timeout (ms) for animation. After timeout, any opening animation will 
      //* be aborted and overlay will be set to opened or not and not animating.
      timeout: 1000,
      openedChanged: function() {
        this.startAnimation();
        // TODO(sorvell): need a controllable api for this, including 
        // maybe focusElement.
        if (this.opened) {
          this.focus();
        }
        this.fireEvent('openedChanged', {opened: this.opened});
      },
      startAnimation: function() {
        this.cancelAnimation();
        this.hidden = false;
        webkitRequestAnimationFrame(function() {
          setBooleanAttribute(this, 'opened', this.opened);
          setBooleanAttribute(this, 'animating', true);
          this._animating = setTimeout(this.finishAnimate.bind(this), this.timeout);
        }.bind(this));
      },
      finishAnimate: function() {
        if (this._animating) {
          this.cancelAnimation();
          setBooleanAttribute(this, 'animating', false);
          if (!this.opened) {
            this.hidden = true;
          }
        }
      },
      cancelAnimation: function() {
        if (this._animating) {
          clearTimeout(this._animating);
          this._animating = null;
        }
      },
      //* Toggle the opened state of the overlay.
      toggle: function() {
        this.opened = !this.opened;
      },
      clickHandler: function(e) {
        if (e.target && e.target.hasAttribute('overlay-toggle')) {
          this.toggle();
        }
      },
      keydownHandler: function(e) {
        if (e.keyCode == 27) {
          this.opened = false;
        }
      }
    }
  });
</script>
</element>