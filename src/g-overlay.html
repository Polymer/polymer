<!--
/*
 * Copyright 2012 The Toolkitchen Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
-->
<element name="g-overlay" attributes="opened, timeout" 
         handlers="click: clickHandler, keydown: keydownHandler,
         webkitAniamtionEnd: finishAnimate, webkitTransitionEnd: finishAnimate">
<link rel="components" href="g-component.html">
<link rel="stylesheet" href="css/g-overlay.css">
<template>
	<content></content>
</template>
<script>
  var ESCAPE_KEY = 27;
  
  /**
   * The overlay component is hidden by default and can be opened to display
   * its content. It's common to animate an overlay opened and closed. This 
   * can be achieved by styling the overlay node via the `opened` and
   * `animating` attributes.
  */
  this.component({
    shadowRootCreated: function() {
      this.hidden = true;
    },
    created: function() {
      // make focusable; note that default tabIndex == -1 but node is 
      // only focusable if tabIndex attr is set.
      if (this.tabIndex < 0) {
        this.tabIndex = -1;
      }
    },
    prototype: {
      //* Timeout (ms) for animation. After timeout, any opening animation will 
      //* be aborted and overlay will be set to opened or not and not animating.
      timeout: 1000,
      openedChanged: function() {
        this.startAnimation();
        // TODO(sorvell): need a controllable api for this, including 
        // maybe focusElement.
        if (this.opened) {
          this.focus();
        }
        this.fireEvent('openedChanged', {opened: this.opened});
      },
      startAnimation: function() {
        this.cancelAnimation();
        this.hidden = false;
        this._animating = setTimeout(this.finishAnimate.bind(this), this.timeout);
        this.asyncMethod('styleAnimationStart');
      },
      styleAnimationStart: function() {
        this.classList.toggle('opened', this.opened);
        this.classList.add('animating');
      },
      finishAnimate: function() {
        if (this._animating) {
          this.cancelAnimation();
          this.classList.remove('animating');
          if (!this.opened) {
            this.hidden = true;
          }
        }
      },
      cancelAnimation: function() {
        if (this._animating) {
          clearTimeout(this._animating);
          this._animating = null;
        }
      },
      //* Toggle the opened state of the overlay.
      toggle: function() {
        this.opened = !this.opened;
      },
      clickHandler: function(e) {
        if (e.target && e.target.hasAttribute('overlay-toggle')) {
          this.toggle();
        }
      },
      keydownHandler: function(e) {
        if (e.keyCode == ESCAPE_KEY) {
          this.opened = false;
        }
      }
    }
  });
</script>
</element>