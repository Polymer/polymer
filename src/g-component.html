<!--
Copyright 2012 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<element name="g-component">
  <script>
    this.lifecycle({
      shadowRootCreated: function() {
      }
    });
  </script>
  <script>
    // polyfill for DOMTokenList features: list of classes in add/remove; 
    // enable method.
    (function() {
      'use strict';
      var add = DOMTokenList.prototype.add;
      var remove = DOMTokenList.prototype.remove;
      DOMTokenList.prototype.add = function() {
        for (var i = 0; i < arguments.length; i++) {
         add.call(this, arguments[i]);
        }
      };
      DOMTokenList.prototype.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
         remove.call(this, arguments[i]);
        }
      };
      DOMTokenList.prototype.enable = function(name, value) {
        value ? this.add(name) : this.remove(name);
      };
    })();
    
    (function(){
      var bindAttrs = function(inAttrs) {
        inAttrs.forEach(function(a) {
          a = a.trim();
          Object.defineProperty(this, a, {
            get: function() {
              return this.hasAttribute(a) ? this.getAttribute(a) :
                this.__proto__[a];
            },
            set: function(v) {
              return this.setAttribute(a, v);
            }
          })
        }, this);
      };

      var bindEvents = function(inEvents) {
        inEvents.forEach(function(e) {
          // event name: handler name pairs
          var pair = e.split(":");
          var event = pair[0].trim();
          var handler = pair[1].trim();
          if (this[handler]) {
            this.addEventListener(event, this[handler].bind(this));
          }
        }, this);
      };
      
      var deref = function(inNode) {
        return inNode.baby || inNode;
      };

      var establishNodeReferences = function(inRoot) {
        this.$ = this.$ || {};
        // search the LOCAL tree
        var nodes = ShadowDOM.localQueryAll(inRoot, "[id]");
        Array.prototype.forEach.call(nodes, function(n) {
          this.$[n.id] = deref(n);
        }, this);
      };

      var handleMutations = function(inMxns) {
        inMxns.forEach(function(inMxn) {
          var name = inMxn.attributeName, method = name + "AttributeChanged";
          if (this[method]) {
            this[method](inMxn.target.getAttribute(name), inMxn.oldValue);
          }
        }, this);
      };

      var AttrObserver = function(inNode) {
        var observer = new WebKitMutationObserver(handleMutations.bind(inNode));
        observer.observe(inNode, {
          attributes: true,
          attributeOldValue: true
        });
        return observer;
      };

      var shadowRootCreated = function(inRoot, inUber, inAttributes) {
        if (inAttributes.attributes) {
          var attributes = inAttributes.attributes.value.split(",");
          bindAttrs.call(this, attributes);
        }
        if (inAttributes.handlers) {
          var events = inAttributes.handlers.value.split(",");
          bindEvents.call(this, events);
        }
        establishNodeReferences.call(this, inRoot);
        if (inUber.shadowRootCreated) {
          inUber.shadowRootCreated(inRoot);
        }
        this.attrObserver = new AttrObserver(this);
      };

      // utility methods
      
      var job = function(inJobName, inJob, inWait) {
        job.stop(inJobName);
        job._jobs[inJobName] = setTimeout(function() {
          job.stop(inJobName);
          inJob();
        }, inWait);
      };
      job.stop = function(inJobName) {
        if (job._jobs[inJobName]) {
          clearTimeout(job._jobs[inJobName]);
          delete job._jobs[inJobName];
        }
      };
      job._jobs = {};
      
      var utils = {
        job: job
      };
      
      // decorate HTMLElementElement with toolkit API
      
      HTMLElementElement.prototype.component = function(inUber) {
        var attributes = this.element.attributes;
        this.lifecycle({
          shadowRootCreated: function(inRoot) {
           shadowRootCreated.call(this, inRoot, inUber, attributes);
          },
          created: inUber.created
        });
        var p = this.generatedConstructor.prototype = inUber.prototype;
        // attach utility library
        // TODO(sjmiles): this is probably not the best way to do this
        p.utils = utils;
      };
      
      // code below provides a shim for declarative event handlers
      // (aka 'x', as in onclick="x('click')")
      // it's only really for evaluating syntax, and not 
      // a real solution
      
      var nodeIterator = function(inNodes, inFn) {
        if (inNodes) {
          for (var i=0, n; (n=inNodes[i]); i++) {
            var v = inFn(n);
            if (v !== undefined) {
              return v;
            }
          }
        }
      };

      var inPublicTree = function(inNodes, inNode) {
        return nodeIterator(inNodes, function(n) {
          if (inNode == n || inPublicTree(n.lightDOM, inNode)) {
            return true;
          }
        });
      };

      var findOwner = function(inNode) {
        // find the root of the LOCAL tree that contains 'this'
        //
        // find a parent who is a component
        // ask if we are in his LOCAL tree
        // repeat
        //
        var t = inNode.parentNode;
        while (t) {
          if (t.__upgraded__) {
            if (inPublicTree(t.childNodes, inNode)) {
              return t;
            };
          }
          t = t.parentNode;
        }
      };

      // experimental event handler for mapping events to component instances
      // publish handler globally, make name as small as possible since
      // this is ideally an invisible helper API
      x = function(inHandler) {
        var owner = findOwner(event.currentTarget);
        //console.log(inHandler, owner, event);
        if (owner && owner[inHandler]) {
          owner[inHandler](event);
        }
      };

    })();
  </script>
</element>

