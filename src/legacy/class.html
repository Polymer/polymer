<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../elements/legacy-element.html">
<link rel="import" href="../utils/utils.html">
<script>

  (function() {

    'use strict';

    let utils = Polymer.Utils;
    let LegacyElementMixin = Polymer.LegacyElementMixin;

    let metaProps = {
      attached: true,
      detached: true,
      ready: true,
      created: true,
      beforeRegister: true,
      registered: true,
      attributeChanged: true,
      // meta objects
      behaviors: true,
      hostAttributes: true,
      properties: true,
      observers: true,
      listeners: true
    }

    function mixinBehaviors(behaviors, klass) {
      if (!behaviors) {
        return klass;
      }
      if (!Array.isArray(behaviors)) {
        behaviors = [behaviors];
      }
      let superBehaviors = klass.behaviors;
      // get flattened, deduped list of behaviors *not* already on super class
      behaviors = flattenBehaviors(behaviors, null, superBehaviors);
      // mixin new behaviors
      klass = _mixinBehaviors(behaviors, klass);
      // TODO(sorvell): checkon this...
      //behaviors.reverse();
      if (superBehaviors) {
        behaviors = superBehaviors.concat(behaviors);
      }
      klass.behaviors = behaviors;
      return klass;
    }

    function _mixinBehaviors(behaviors, klass) {
      for (let i=0; i<behaviors.length; i++) {
        let b = behaviors[i];
        if (b) {
          klass = Array.isArray(b) ? _mixinBehaviors(b, klass) :
            GenerateClassFromInfo(b, klass);
        }
      }
      return klass;
    }

    function flattenBehaviors(behaviors, list, exclude) {
      list = list || [];
      for (let i=0; i < behaviors.length; i++) {
        let b = behaviors[i];
        if (b) {
          if (Array.isArray(b)) {
            flattenBehaviors(b, list);
          } else {
            // dedup
            if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
              list.push(b);
            }
          }
        } else {
          Polymer._warn('behavior is null, check for missing or 404 import');
        }
      }
      return list;
    }

    function GenerateClassFromInfo(info, Base) {

      let config = {
        properties: info.properties,
        observers: info.observers,
        generatedFrom: info
      };

      class PolymerGenerated extends Base {

        static get config() {
          return config;
        }

        static get template() {
          return info._template || super.template || this.prototype._template;
        }

        _invokeFunction(fn, args) {
          if (fn) {
            fn.apply(this, args);
          }
        }

        _initializeProperties() {
          // call `registered` only if it was not called for *this* constructor
          if (!PolymerGenerated.hasOwnProperty('__registered')) {
            PolymerGenerated.__registered = true;
            if (info.registered) {
              info.registered.call(Object.getPrototypeOf(this));
            }
          }
          super._initializeProperties();
        }

        created() {
          super.created();
          this._invokeFunction(info.created);
        }

        _applyListeners() {
          super._applyListeners();
          this._applyConfigListeners(info);
        }

        _ensureAttributes() {
          // ensure before calling super so that subclasses can override defaults
          this._ensureConfigAttributes(info);
          super._ensureAttributes();
        }

        ready() {
          super.ready();
          this._invokeFunction(info.ready);
        }

        attached() {
          super.attached();
          this._invokeFunction(info.attached);
        }

        detached() {
          super.detached();
          this._invokeFunction(info.detached);
        }

        attributeChanged(name, old, value) {
          super.attributeChanged(name, old, value);
          this._invokeFunction(info.attributeChanged, [name, old, value]);
        }
      }

      for (let p in info) {
        if (!(p in metaProps))
          utils.copyOwnProperty(p, info, PolymerGenerated.prototype);
      }

      return PolymerGenerated;
    }

    //let nativeConstructors = {};

    /**
     * Returns the native element constructor for the tag specified.
     *
     * @method getNativeConstructor
     * @param {string} tag  HTML tag name.
     * @return {Object} Native constructor for specified tag.
    */
    let getNativeConstructor = function(tag) {
      if (tag) {
        // TODO(kschaaf): hack, for now, needs to be removed; needed to allow
        // subclassing from overwridden constructors in CEv1 polyfill
        return window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element'];
        // let c = nativeConstructors[tag];
        // if (!c) {
        //   c = document.createElement(tag).constructor;
        //   nativeConstructors[tag] = c;
        // }
        // return c;
      } else {
        return HTMLElement;
      }
    }

    Polymer.Class = function(info) {
      if (!info) {
        Polymer._warn('Polymer.Class requires `info` argument');
      }
      let klass = LegacyElementMixin(getNativeConstructor(info.extends));
      if (info.behaviors) {
        klass = mixinBehaviors(info.behaviors, klass);
      }
      klass = GenerateClassFromInfo(info, klass);
      // decorate klass with registration info
      klass.is = info.is;
      klass.extends = info.extends;
      // behaviors on prototype for BC...
      klass.prototype.behaviors = klass.behaviors;
      // NOTE: while we could call `beforeRegister` here to maintain
      // some BC, the state of the element at this point is not as it was in 1.0
      // In 1.0, the method was called *after* mixing prototypes together
      // but before processing of meta-objects. Since this is now done
      // in 1 step via `GenerateClassFromInfo`, this is no longer possible.
      // However, *most* work (not setting `is`) that was previously done in
      // `beforeRegister` should be possible in `registered`.
      return klass;
    }

    Polymer.mixinBehaviors = mixinBehaviors;

  })();

</script>
