<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="legacy-element.html">
<link rel="import" href="../utils/utils.html">
<script>

  (function() {

    'use strict';

    let utils = Polymer.Utils;
    let LegacyElementMixin = Polymer.LegacyElementMixin;

    let metaProps = {
      attached: true,
      detached: true,
      ready: true,
      created: true,
      beforeRegister: true,
      registered: true,
      attributeChanged: true,
      // meta objects
      behaviors: true,
      hostAttributes: true,
      properties: true,
      observers: true,
      listeners: true
    }

    function mixinBehaviors(behaviors, klass) {
      if (!behaviors) {
        return klass;
      }
      // NOTE: ensure the bahevior is extending a class with
      // legacy element api. This is necessary since behaviors expect to be able
      // to access 1.x legacy api.
      klass = LegacyElementMixin(klass);
      if (!Array.isArray(behaviors)) {
        behaviors = [behaviors];
      }
      let superBehaviors = klass.behaviors;
      // get flattened, deduped list of behaviors *not* already on super class
      behaviors = flattenBehaviors(behaviors, null, superBehaviors);
      // mixin new behaviors
      klass = _mixinBehaviors(behaviors, klass);
      if (superBehaviors) {
        behaviors = superBehaviors.concat(behaviors);
      }
      klass.behaviors = behaviors;
      return klass;
    }

    // NOTE:
    // 1.x
    // Behaviors were mixed in *in reverse order* and de-duped on the fly.
    // The rule was that behavior properties were copied onto the element
    // prototype if and only if the property did not already exist.
    // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
    // (1), B, (2), A, (3) C. This means prototype properties win over
    // B properties win over A win over C. This mirrors what would happen
    // with inheritance if element extended B extended A extended C.
    //
    // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
    // `behaviors` array was [C, A, B].
    // Behavior lifecycle methods were called in behavior array order
    // followed by the element, e.g. (1) C.created, (2) A.created,
    // (3) B.created, (4) element.created. There was no support for
    // super, and "super-behavior" methods were callable only by name).
    //
    // 2.x
    // Behaviors are made into proper mixins which live in the
    // element's prototype chain. Behaviors are placed in the element prototype
    // eldest to youngest and de-duped youngest to oldest:
    // So, first [A, B, C, A, B] becomes [C, A, B] then,
    // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
    // (3) class(A), (4) class(B), (5) class(Polymer({...})).
    // Result:
    // This means element properties win over B properties win over A win
    // over C. (same as 1.x)
    // If lifecycle is called (super then me), order is
    // (1) C.created, (2) A.created, (3) B.created, (4) element.created
    // (again same as 1.x)
    function _mixinBehaviors(behaviors, klass) {
      for (let i=0; i<behaviors.length; i++) {
        let b = behaviors[i];
        if (b) {
          klass = Array.isArray(b) ? _mixinBehaviors(b, klass) :
            GenerateClassFromInfo(b, klass);
        }
      }
      return klass;
    }

    /**
     * @param {Array} behaviors
     * @param {Array=} list
     * @param {Array=} exclude
     */
    function flattenBehaviors(behaviors, list, exclude) {
      list = list || [];
      for (let i=behaviors.length-1; i >= 0; i--) {
        let b = behaviors[i];
        if (b) {
          if (Array.isArray(b)) {
            flattenBehaviors(b, list);
          } else {
            // dedup
            if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
              list.unshift(b);
            }
          }
        } else {
          Polymer._warn('behavior is null, check for missing or 404 import');
        }
      }
      return list;
    }

    function GenerateClassFromInfo(info, Base) {

      let config = {
        properties: info.properties,
        observers: info.observers,
        generatedFrom: info
      };

      let registered = false;

      class PolymerGenerated extends Base {

        static get config() {
          return config;
        }

        static _getTemplate() {
          return info._template || super._getTemplate() ||
            this.prototype._template;
        }

        created() {
          super.created();
          if (info.created) {
            info.created.call(this);
          }
        }

        _registered() {
          if (!registered) {
            super._registered();
            // call `registered` only if it was not called for *this* constructor
            registered = true;
            if (info.registered) {
              info.registered.call(Object.getPrototypeOf(this));
            }
          }
        }

        _applyListeners() {
          super._applyListeners();
          if (info.listeners) {
            for (let l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.
        _ensureAttributes() {
          if (info.hostAttributes) {
            for (let a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          super._ensureAttributes();
        }

        ready() {
          super.ready();
          if (info.ready) {
            info.ready.call(this);
          }
        }

        attached() {
          super.attached();
          if (info.attached) {
            info.attached.call(this);
          }
        }

        detached() {
          super.detached();
          if (info.detached) {
            info.detached.call(this);
          }
        }

        attributeChanged(name, old, value) {
          super.attributeChanged(name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
       }
      }

      for (let p in info) {
        // NOTE: cannot copy `metaProps` methods onto prototype at least because
        // `super.ready` must be called and is not included in the user fn.
        if (!(p in metaProps))
          utils.copyOwnProperty(p, info, PolymerGenerated.prototype);
      }

      return PolymerGenerated;
    }

    /**
     * Returns the native element constructor for the tag specified.
     *
     * @method getNativeConstructor
     * @param {string} tag  HTML tag name.
     * @return {Object} Native constructor for specified tag.
    */
    // TODO(sorvell): currently `extends` is not supported.
    let getNativeConstructor = function() {
      return HTMLElement;
    }

    Polymer.Class = function(info) {
      if (!info) {
        Polymer._warn('Polymer.Class requires `info` argument');
      }
      let klass = getNativeConstructor(info.extends);
      if (info.behaviors) {
        // note: mixinBehaviors ensures `LegacyApiMixin`.
        klass = mixinBehaviors(info.behaviors, klass);
      } else {
        klass = LegacyElementMixin(getNativeConstructor(info.extends));
      }
      klass = GenerateClassFromInfo(info, klass);
      // decorate klass with registration info
      klass.is = info.is;
      klass.extends = info.extends;
      // behaviors on prototype for BC...
      klass.prototype.behaviors = klass.behaviors;
      // NOTE: while we could call `beforeRegister` here to maintain
      // some BC, the state of the element at this point is not as it was in 1.0
      // In 1.0, the method was called *after* mixing prototypes together
      // but before processing of meta-objects. Since this is now done
      // in 1 step via `GenerateClassFromInfo`, this is no longer possible.
      // However, *most* work (not setting `is`) that was previously done in
      // `beforeRegister` should be possible in `registered`.
      return klass;
    }

    Polymer.mixinBehaviors = mixinBehaviors;

  })();

</script>
