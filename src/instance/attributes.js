/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // instance api for attributes

  var attributes = {
    copyInstanceAttributes: function () {
      var a$ = this._instanceAttributes;
      for (var k in a$) {
        if (!this.hasAttribute(k)) {
          this.setAttribute(k, a$[k]);
        }
      }
    },
    // for each attribute on this, deserialize value to property as needed
    takeAttributes: function() {
      // if we have no publish lookup table, we have no attributes to take
      // TODO(sjmiles): ad hoc
      if (this._publishLC) {
        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {
          this.attributeToProperty(a.name, a.value);
        }
      }
    },
    // if attribute 'name' is mapped to a property, deserialize
    // 'value' into that property
    attributeToProperty: function(name, value) {
      // try to match this attribute to a property (attributes are
      // all lower-case, so this is case-insensitive search)
      var name = this.propertyForAttribute(name);
      if (name) {
        // filter out 'mustached' values, these are to be
        // replaced with bound-data and are not yet values
        // themselves
        if (value && value.search(scope.bindPattern) >= 0) {
          return;
        }
        // get original value
        var defaultValue = this[name];
        // deserialize Boolean or Number values from attribute
        var value = this.deserializeValue(value, defaultValue);
        // only act if the value has changed
        if (value !== defaultValue) {
          // install new value (has side-effects)
          this[name] = value;
        }
      }
    },
    // return the published property matching name, or undefined
    propertyForAttribute: function(name) {
      var match = this._publishLC && this._publishLC[name];
      //console.log('propertyForAttribute:', name, 'matches', match);
      return match;
    },
    // convert representation of 'stringValue' based on type of 'defaultValue'
    deserializeValue: function(stringValue, defaultValue) {
      return scope.deserializeValue(stringValue, defaultValue);
    },
    serializeValue: function(value, inferredType) {
      if (inferredType === 'boolean') {
        return value ? '' : undefined;
      } else if (inferredType !== 'object' && typeof value !== 'object' &&
          value !== undefined) {
        return value;
      }
    },
    reflectPropertyToAttribute: function(name) {
      //if (Object.keys(this[PUBLISHED]).indexOf(name) >= 0) {
        // TODO(sjmiles): consider memoizing this
        var inferredType = typeof this.__proto__[name];
        // try to intelligently serialize property value
        var serializedValue = this.serializeValue(this[name], inferredType);
        // boolean properties must reflect as boolean attributes
        if (serializedValue !== undefined) {
          this.setAttribute(name, serializedValue);
          // TODO(sorvell): we should remove attr for all properties
          // that have undefined serialization; however, we will need to
          // refine the attr reflection system to achieve this; pica, for example,
          // relies on having inferredType object properties not removed as
          // attrs.
        } else if (inferredType === 'boolean') {
          this.removeAttribute(name);
        }
      //}
    }
  };

  // exports

  scope.api.instance.attributes = attributes;

})(Polymer);
