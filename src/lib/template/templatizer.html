<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>

  Polymer.Templatizer = {

    templatize: function(template) {
      this._templatized = template;
      // TODO(sjmiles): supply _alternate_ content reference missing from root
      // templates (not nested). `_content` exists to provide content sharing
      // for nested templates.
      if (!template._content) {
        template._content = template.content;
      }
      // fast path if template's anonymous class has been memoized
      if (template._content._ctor) {
        this.ctor = template._content._ctor;
        //console.log('Templatizer.templatize: using memoized archetype');
        // forward parent properties to archetype
        this._prepParentProperties(this.ctor.prototype._parentProps);
        return;
      }
      // `archetype` is the prototype of the anonymous
      // class created by the templatizer 
      var archetype = Object.create(Polymer.Base);
      archetype.host = this;
      archetype.contentHost = this._getContentHost();
      // normally Annotations.parseAnnotations(template) but
      // archetypes do special caching
      this.customPrepAnnotations(archetype, template);
      // setup accessors
      archetype._prepEffects();
      // forward parent properties to archetype
      this._prepParentProperties(archetype._parentProps);
      // late-binds archetype.listen to host.listen; h.l doesn't exist yet
      archetype.listen = function() { 
        this.listen.apply(this, arguments);
      }.bind(this.host);

      // boilerplate code
      archetype._notifyPath = this._notifyPathImpl;
      // boilerplate code
      var _constructor = this._constructorImpl;
      var ctor = function TemplateInstance(model) {
        _constructor.call(this, model);
      };
      // standard references
      ctor.prototype = archetype;
      archetype.constructor = ctor;
      // TODO(sjmiles): constructor cache?
      template._content._ctor = ctor;
      // TODO(sjmiles): choose less general name
      this.ctor = ctor;
    },

    _getContentHost: function() {
      return (this.host && this.host.contentHost) || this.host;
    },

    _getAllStampedChildren: function(children) {
      children = children || [];
      if (this._getStampedChildren) {
        var c$ = this._getStampedChildren();
        for (var i=0, c; c = c$[i]; i++) {
          children.push(c);
          if (c._getAllStampedChildren) {
            c._getAllStampedChildren(children);
          }
        }
      }
      return children;
    },

    customPrepAnnotations: function(archetype, template) {
      if (template) {
        archetype._template = template;
        var c = template._content;
        if (c) {
          archetype._annotes = c._annotes;
          archetype._parentProps = c._parentProps;
        } 
        else {
          console.warn('no _content');
        }
      }
      else {
        console.warn('no _template');
      }
    },

    _prepParentProperties: function(parentProps) {
      if (this._forwardParentProp) {
        if (this._templatized != this) {
          // templatized template is probably not a Polymer.Base...
          Polymer.Bind.prepareModel(this._templatized);
          Polymer.Bind.prepareInstance(this._templatized);
          this._templatized._forwardParentProp =
            this._forwardParentProp.bind(this);
        }
        if (this._parentProps = parentProps) {
          for (var prop in parentProps) {
            var parentProp = '_parent_' + prop;
            var val = this._templatized[parentProp];
            Polymer.Bind._bindPropertyEffects(this._templatized, parentProp,
              ['this._forwardParentProp(\'' + prop + '\', this._data.' + parentProp + ')']);
            this._templatized._setData(parentProp, val);
          }
        }
      }
    },

    _notifyPathImpl: function(path, value) {
      var p = path.match(/([^.]*)\.(([^.]*).*)/);
                          // 'root.sub.path'
      var root = p[1];    // 'root'
      var sub = p[3];     // 'sub'
      var subPath = p[2]; // 'sub.path'
      // Notify host of parent.* path/property changes
      var host = this._dataHost;
      if (root == 'parent') {
        if (sub == subPath) {
          host._dataHost[sub] = value;
        } else {
          host.notifyPath('_parent_' + subPath, value);
        }        
      }
      // Extension point for Templatizer sub-classes
      if (host._forwardInstancePath) {
        host._forwardInstancePath.call(host, this, root, subPath, value);
      }
    },

    // Overrides Base notify-path module
    _pathEffector: function(path, value, fromAbove) {
      if (this._forwardParentPath) {
        if (path.indexOf('_parent_') === 0) {
          this._forwardParentPath(path.substring(8), value);
        }
      }
      Polymer.Base._pathEffector.apply(this, arguments);
    },

    _constructorImpl: function(model) {
      this._setupConfigure(model);
      this._pushHost(this.host);
      this.root = this.instanceTemplate(this._template);
      this.root.__styleScoped = true;
      this._popHost();
      this._marshalAnnotatedNodes();
      this._marshalInstanceEffects();
      this._marshalAnnotatedListeners();
      this._readyContent();
    },

    stamp: function(model) {
      model = model || {};
      if (this._parentProps) {
        model.parent = model.parent || {};
        for (var prop in this._parentProps) {
          model.parent[prop] = this['_parent_' + prop];
        }        
      }
      return new this.ctor(model);
    }

    // TODO(sorvell): note, using the template as host is ~5-10% faster if 
    // elements have no default values.
    // _constructorImpl: function(model, host) {
    //   this._setupConfigure(model);
    //   host._beginHost();
    //   this.root = this.instanceTemplate(this._template);
    //   host._popHost();
    //   this._marshalTemplateContent();
    //   this._marshalAnnotatedNodes();
    //   this._marshalInstanceEffects();
    //   this._marshalAnnotatedListeners();
    //   this._ready();
    // },

    // stamp: function(model) {
    //   return new this.ctor(model, this.host);
    // }
    

  };

</script>