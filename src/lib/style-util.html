<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="css-parse.html">

<script>

  Polymer.StyleUtil = (function() {

    return {

      MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
      INCLUDE_ATTR: 'include',

      toCssText: function(rules, callback, preserveProperties) {
        if (typeof rules === 'string') {
          rules = this.parser.parse(rules);
        }
        if (callback) {
          this.forEachRule(rules, callback);
        }
        return this.parser.stringify(rules, preserveProperties);
      },

      forRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
        if (styles) {
          for (var i=0, l=styles.length, s; (i<l) && (s=styles[i]); i++) {
            this.forEachRule(
                this.rulesForStyle(s),
                styleRuleCallback,
                keyframesRuleCallback);
          }
        }
      },

      rulesForStyle: function(style) {
        if (!style.__cssRules && style.textContent) {
          style.__cssRules =  this.parser.parse(style.textContent);
        }
        return style.__cssRules;
      },

      // Tests if a rule is a keyframes selector, which looks almost exactly
      // like a normal selector but is not (it has nothing to do with scoping
      // for example).
      isKeyframesSelector: function(rule) {
        return rule.parent &&
            rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
      },

      forEachRule: function(node, styleRuleCallback, keyframesRuleCallback) {
        if (!node) {
          return;
        }
        var skipRules = false;
        if (node.type === this.ruleTypes.STYLE_RULE) {
          styleRuleCallback(node);
        } else if (keyframesRuleCallback &&
                   node.type === this.ruleTypes.KEYFRAMES_RULE) {
          keyframesRuleCallback(node);
        } else if (node.type === this.ruleTypes.MIXIN_RULE) {
          skipRules = true;
        }
        var r$ = node.rules;
        if (r$ && !skipRules) {
          for (var i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {
            this.forEachRule(r, styleRuleCallback, keyframesRuleCallback);
          }
        }
      },

      // add a string of cssText to the document.
      applyCss: function(cssText, moniker, target, afterNode) {
        var style = document.createElement('style');
        if (moniker) {
          style.setAttribute('scope', moniker);
        }
        style.textContent = cssText;
        target = target || document.head;
        if (!afterNode) {
          var n$ = target.querySelectorAll('style[scope]');
          afterNode = n$[n$.length-1];
        }
        target.insertBefore(style,
          (afterNode && afterNode.nextSibling) || target.firstChild);
        return style;
      },

      cssFromModules: function(moduleIds, deep, warnIfNotFound) {
        var modules = moduleIds.trim().split(' ');
        var cssText = '';
        for (var i=0; i < modules.length; i++) {
          cssText += this.cssFromModule(modules[i], deep, warnIfNotFound);
        }
        return cssText;
      },

      // returns cssText of styles in a given module; also un-applies any
      // styles that apply to the document.
      cssFromModule: function(moduleId, deep, warnIfNotFound) {
        var m = Polymer.DomModule.import(moduleId);
        if (!m && warnIfNotFound) {
          console.warn('Could not find style data in module named', moduleId);
        }
        return m ? this.cssFromElement(m, deep) : '';
      },

      // support lots of ways to discover css...
      cssFromElement: function(element, deep) {
        var cacheKey = deep ? '__cssTextDeep' : '__cssText';
        if (!element[cacheKey]) {
          var cssText = '';
          // if element is a template, get content from its .content
          var content = element.content || element;
          var e$ = Polymer.TreeApi.arrayCopy(
            content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
          for (var i=0, e; i < e$.length; i++) {
            e = e$[i];
            // look inside templates for elements
            if (e.localName === 'template' && deep) {
              cssText += this.cssFromElement(e, deep);
            } else {
              // style elements inside dom-modules will apply to the main 
              // document we don't want this, so we remove them here.
              if (e.localName === 'style') {
                var include = e.getAttribute(this.INCLUDE_ATTR);
                // now support module refs on 'styling' elements
                if (include) {
                  cssText += this.cssFromModules(include, true);
                }
                // get style element applied to main doc via HTMLImports 
                // polyfill
                if (element.localName !== 'template') {
                  e = e.__appliedElement || e;
                  e.parentNode.removeChild(e);
                }
                cssText += this.resolveCss(e.textContent, 
                  element.ownerDocument);
              // it's an import, assume this is a text file of css content.
              // TODO(sorvell): plan is to deprecate this way to get styles;
              // remember to add deprecation warning when this is done.
              } else if (e.import && e.import.body) {
                cssText += this.resolveCss(e.import.body.textContent, e.import);
              }
            }
          }
          element[cacheKey] = cssText;
        }
        return element[cacheKey];
      },

      removeStyles: function(element) {
        var s$ = element.querySelectorAll('style');
        for (var i=0, e; i < s$.length; i++) {
          e = s$[i];
          e = e.__appliedElement || e;
          e.parentNode.removeChild(e);
        }
      },

      removeStyleRules: function(styles) {
        for (var i=0; i < styles.length; i++) {
          styles[i].__cssRules = null;
        }
      },

      resolveCss: Polymer.ResolveUrl.resolveCss,
      parser: Polymer.CssParse,
      ruleTypes: Polymer.CssParse.types

    };

  })();

</script>
