<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>
(function(scope) {
  'use strict';

  /** @type {Object<key, *>} A mapping of ids to modules. */
  var _modules = Object.create(null);

  // `define`

  /**
   * An AMD-compliant implementation of `define` that does not perform loading.
   *
   * @see https://github.com/amdjs/amdjs-api/wiki/AMD
   *
   * Dependencies must be loaded prior to calling `define`, or you will receive
   * an error.
   *
   * @param {string=} id The id of the module being defined. If not provided,
   *     one will be given to the module based on the document it was called in.
   * @param {Array<string>=} dependencies A list of module ids that should be
   *     exposed as dependencies of the module being defined.
   * @param {function(...*)|*} factory A function that is given the exported
   *     values for `dependencies`, in the same order. Alternatively, you can
   *     pass the exported value directly.
   */
  function define(id, dependencies, factory) {
    factory = factory || dependencies || id;
    // TODO(nevir): Assign directly as exports if not a function.
    if (typeof factory !== 'function') {
      throw new TypeError('The last argument to define() must be a function');
    }

    if (!Array.isArray(dependencies)) {
      // TODO(nevir): Default dependencies should be require, exports, module.
      dependencies = Array.isArray(id) ? id : [];
    }

    if (typeof id !== 'string') {
      id = _inferModuleId();
    }

    if (id in _modules) {
      throw new Error('The module "' + id + '" has already been defined');
    }

    _modules[id] = _withDependencies(dependencies, factory);
    return _modules[id];
  }
  // Semi-private. We expose this for tests & introspection.
  define._modules = _modules;

  /**
   * Let other implementations know that this is an AMD implementation.
   * @see https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property-
   */
  define.amd = {};

  // Utility

  // TODO(nevir): Temporary for anonymous module ids until we determine them via
  // current script URL.
  var _anonymousModuleCount = 0;

  /** @return {string} A module id inferred from the current document/import. */
  function _inferModuleId() {
    return '__anonymous_' + _anonymousModuleCount++ + '__';
  }

  /**
   * Calls `factory` with the exported values of `dependencies`.
   *
   * @param {Array<string>} dependencies
   * @param {function(...*)} factory
   */
  function _withDependencies(dependencies, factory) {
    var modules = dependencies.map(function(id) {
      if (!(id in _modules)) {
        throw new ReferenceError('The module "' + id + '" has not been loaded');
      }
      return _modules[id];
    });
    return factory.apply(null, modules);
  }

  // Exports

  scope.define = define;

  // TODO(nevir): Do we want to also implement AMD's (optional) global `require`
  // function? It doesn't support relative lookups, so that may be a no-go:
  // https://github.com/amdjs/amdjs-api/blob/master/require.md

  // TODO(nevir): Get rid of these; they're purely transitionary.
  scope.modulate = function(id, dependencies, factory) {
    dependencies = typeof dependencies === 'string' ? [dependencies] : dependencies;
    define(id, dependencies, factory);
  };
  scope.using = function(dependencies, factory) {
    dependencies = typeof dependencies === 'string' ? [dependencies] : dependencies;
    define(dependencies, factory);
  };


})(this);
</script>
