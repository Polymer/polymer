<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="element.html">
<link rel="import" href="../utils/utils.html">
<link rel="import" href="../utils/compat-utils.html">

<script>
(function() {

  'use strict';

  var utils = Polymer.Utils;

  function nyi() {
    var stack = new Error().stack.split('\n');
    var fn = stack.reduce(function(prev, val) {
      return prev == true ? val : (prev ? prev :
        val.indexOf('compat-element.html') > 0);
    }, false);
    console.warn('Not yet implemented:', fn);
  }

  // TODO(sorvell): same api as before.
  Polymer._warn = function(warning) {
    console.warn(warning);
  }

  function CompatElementMixin(Base) {

    return class CompatElement extends Polymer.ElementMixin(Base) {

      constructor() {
        super();
        this.created();
      }

      ready() {
        super.ready();
        var config = this.constructor._ownConfig;
        if (config.listeners) {
          this.addListeners(config.listeners);
        }
        if (config.hostAttributes) {
          this.ensureAttributes(config.hostAttributes);
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this.attached();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.detached();
      }

      attributeChangedCallback(name, old, value) {
        super.attributeChangedCallback(name, old, value);
        this.attributeChanged(name, old, value);
      }

      created() {}

      attached() {}

      detached() {}

      attributeChanged() {}

      serialize(value) {
        return this.constructor.attributes.serialize(value);
      }

      deserialize(value, type) {
        return this.constructor.attributes.deserialize(value, type);
      }

      reflectPropertyToAttribute(property, attribute, value) {
        this.constructor.attributes.propertyToAttribute(this, property,
          attribute, value);
      }

      serializeValueToAttribute(value, attribute, node) {
        node = node || this;
        this.constructor.attributes.valueToAttribute(node, value,
          attribute, value);
      }

      /**
       * Copies own properties (including accessor descriptors) from a source
       * object to a target object.
       *
       * @method extend
       * @param {Object} prototype Target object to copy properties to.
       * @param {Object} api Source object to copy properties from.
       * @return {Object} prototype object that was passed as first argument.
       */
      extend(prototype, api) {
        return utils.extend(prototype, api);
      }

      /**
       * Copies props from a source object to a target object.
       *
       * Note, this method uses a simple `for...in` strategy for enumerating
       * properties.  To ensure only `ownProperties` are copied from source
       * to target and that accessor implementations are copied, use `extend`.
       *
       * @method mixin
       * @param {Object} target Target object to copy properties to.
       * @param {Object} source Source object to copy properties from.
       * @return {Object} Target object that was passed as first argument.
       */
      mixin(target, source) {
        return utils.mixin(target, source);
      }

      // TODO(sorvell): move out of here?
      chainObject(object, inherited) {
        if (object && inherited && object !== inherited) {
          if (!Object.__proto__) {
            object = this.extend(Object.create(inherited), object);
          }
          object.__proto__ = inherited;
        }
        return object;
      }

      /* **** Begin Template **** */
      /**
       * Calls `importNode` on the `content` of the `template` specified and
       * returns a document fragment containing the imported content.
       *
       * @method instanceTemplate
       * @param {HTMLTemplateElement} template HTML template element to instance.
       * @return {DocumentFragment} Document fragment containing the imported
       *   template content.
      */
      instanceTemplate(template) {
        var dom =
          document.importNode(template._content || template.content, true);
        return dom;
      }

      /**
       * Rewrites a given URL relative to the original location of the document
       * containing the `dom-module` for this element.  This method will return
       * the same URL before and after vulcanization.
       *
       * @method resolveUrl
       * @param {string} url URL to resolve.
       * @return {string} Rewritten URL relative to the import
       */
      resolveUrl(url) {
        // TODO(sorvell): do we want to put the module reference on the prototype?
        var module = Polymer.DomModule.import(this.is);
        var root = '';
        if (module) {
          var assetPath = module.getAttribute('assetpath') || '';
          root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
        }
        return Polymer.ResolveUrl.resolveUrl(url, root);
      }

      /* **** Begin Events **** */
      fire(type, detail, options) {
        options = options || {};
        detail = (detail === null || detail === undefined) ? {} : detail;
        var event = new Event(type, {
          bubbles: options.bubbles === undefined ? true : options.bubbles,
          cancelable: Boolean(options.cancelable),
          composed: options.composed === undefined ? true: options.composed
        });
        event.detail = detail;
        var node = options.node || this;
        node.dispatchEvent(event)
        return event;
      }

      listen(node, eventName, methodName) {
        node = node || this;
        var hbl = this.__boundListeners ||
          (this.__boundListeners = new WeakMap());
        var bl = hbl.get(node);
        if (!bl) {
          bl = {};
          hbl.set(node, bl);
        }
        var key = eventName + methodName;
        if (!bl[key]) {
          bl[key] = this.constructor.events.addMethodListener(
            node, eventName, methodName, this);
        }
      }

      unlisten(node, eventName, methodName) {
        node = node || this;
        var bl = this.__boundListeners && this.__boundListeners.get(node);
        var key = eventName + methodName;
        var handler = bl && bl[key];
        if (handler) {
          this.constructor.events.removeListener(node, eventName, handler);
          bl[key] = null;
        }
      }

      /**
       * Override scrolling behavior to all direction, one direction, or none.
       *
       * Valid scroll directions:
       *   - 'all': scroll in any direction
       *   - 'x': scroll only in the 'x' direction
       *   - 'y': scroll only in the 'y' direction
       *   - 'none': disable scrolling for this node
       *
       * @method setScrollDirection
       * @param {String=} direction Direction to allow scrolling
       * Defaults to `all`.
       * @param {HTMLElement=} node Element to apply scroll direction setting.
       * Defaults to `this`.
       */
      setScrollDirection(direction, node) {
        node = node || this;
        this.constructor.events.constructor.lib.
          setTouchAction(node, direction || 'auto');
      }
      /* **** End Events **** */

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @method $$
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */
      $$(slctr) {
        return $Array.copy(this.root.querySelector(slctr));
      }

      domHost() {
        return nyi();
      }

      distributeContent(updateInsertionPoints) {
        return nyi();
      }

      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       *
       * @method getEffectiveChildNodes
       * @return {Array<Node>} List of effctive child nodes.
       */
      getEffectiveChildNodes() {
        var list = [];
        var c$ = this.childNodes;
        for (var i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
          // BREAKME(sorvell): remove when V0 ShadowDom support is removed.
          var d$ = (c.localName === 'content') ? c.getDistributedNodes() :
            ((c.localName === 'slot') ? c.assignedNodes({flatten: true}) : null);
          if (d$) {
           var d$ = c.getDistributedNodes();
            for (var j=0; j < d$.length; j++) {
              list.push(d$[j]);
            }
          } else {
            list.push(c);
          }
        }
        return list;
      }

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @method getEffectiveChildren
       * @return {Array<Node>} List of effctive children.
       */
      getEffectiveChildren() {
        var list = this.getEffectiveChildNodes();
        return list.filter(function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      }

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @method getEffectiveTextContent
       * @return {Array<Node>} List of effctive children.
       */
      getEffectiveTextContent() {
        var cn = this.getEffectiveChildNodes();
        var tc = [];
        for (var i=0, c; (c = cn[i]); i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }

      queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];
        for (var i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
          if ((c.nodeType === Node.ELEMENT_NODE) &&
              utils.matchesSelector.call(c, selector)) {
            list.push(c);
          }
        }
        return list;
      }


      queryEffectiveChildren(slctr) {
        var e$ = this.queryDistributedElements(slctr);
        return e$ && e$[0];
      }

      queryAllEffectiveChildren(slctr) {
        return this.queryDistributedElements(slctr);
      }

      /**
       * Returns a list of nodes distributed to this element's `<content>`.
       *
       * If this element contains more than one `<content>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @method getContentChildNodes
       * @param {String=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<Node>} List of distributed nodes for the `<content>`.
       */
      getContentChildNodes(slctr) {
        var content = this.root.querySelector(slctr || 'content');
        return content ? content.getDistributedNodes() : [];
      }

      /**
       * Returns a list of element children distributed to this element's
       * `<content>`.
       *
       * If this element contains more than one `<content>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @method getContentChildNodes
       * @param {String=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<HTMLElement>} List of distributed nodes for the
       *   `<content>`.
       */
      getContentChildren(slctr) {
        return this.getContentChildNodes(slctr).filter(function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      }

      isLightDescendant(node) {
        return nyi();
      }

      isLocalDescendant(node) {
        return nyi();
      }

      scopeSubtree(container, shouldObserve) {
        if (Polymer.StyleLib.nativeShadow) {
          return;
        }
        Polymer.StyleTransformer.dom(container);
        if (shouldObserve) {
          var mo = new MutationObserver(function(mxns) {
            for (var i = 0, m; i < mxns.length; i++) {
              m = mxns[i];
              if (m.addedNodes) {
                for (var j = 0, n; j < m.addedNodes.length; j++) {
                  n = m.addedNodes[j];
                  Polymer.StyleTransformer.dom(n);
                }
              }
            }
          });
          mo.observe(container, {childList: true, subtree: true});
          return mo;
        }
      }

      getComputedStyleValue(property) {
        var value;
        if (this.__styleProperties) {
          value = this.__styleProperties[property];
        }
        return value || window.getComputedStyle(this).getPropertyValue(property);
      }

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       } 100);
       *     }
       *
       * @method debounce
       * @param {String} jobName String to indentify the debounce job.
       * @param {Function} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       */
      debounce(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = Polymer.Debouncer.debounce(
          this._debouncers[jobName], callback, wait, this);
      }

      /**
       * Returns whether a named debouncer is active.
       *
       * @method isDebouncerActive
       * @param {String} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */
      isDebouncerActive(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      }

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @method flushDebouncer
       * @param {String} jobName The name of the debouncer started with `debounce`
       */
      flushDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      }

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @method cancelDebouncer
       * @param {String} jobName The name of the debouncer started with `debounce`
       */
      cancelDebouncer(jobName) {
        this._debouncers = this._debouncers || {}
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      }

      /**
       * Runs a callback function asyncronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @method async
       * @param {Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */
      async(callback, waitTime) {
        var self = this;
        return Polymer.Async.run(function() {
          callback.call(self);
        }, waitTime);
      }

      /**
       * Cancels an async operation started with `async`.
       *
       * @method cancelAsync
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       */
      cancelAsync(handle) {
        Polymer.Async.cancel(handle);
      }

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @method create
       * @param {string} tag HTML element tag to create.
       * @param {Object} props Object of properties to configure on the
       *    instance.
       * @return {Element} Newly created and configured element.
       */
      create(tag, props) {
        var elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (var n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      }

      getNativePrototype(tag) {
        return nyi();
      }

      getPropertyInfo(property) {
        return nyi();
      }

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @method importHref
       * @param {string} href URL to document to load.
       * @param {Function} onload Callback to notify when an import successfully
       *   loaded.
       * @param {Function} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {HTMLLinkElement} The link element for the URL to be loaded.
       */
      importHref(href, onload, onerror, optAsync) {
        var l = document.createElement('link');
        l.rel = 'import';
        l.href = href;

        optAsync = Boolean(optAsync);
        if (optAsync) {
          l.setAttribute('async', '');
        }

        var self = this;
        if (onload) {
          l.onload = function(e) {
            return onload.call(self, e);
          }
        }
        if (onerror) {
          l.onerror = function(e) {
            return onerror.call(self, e);
          }
        }
        document.head.appendChild(l);
        return l;
      }

      elementMatches(selector, node) {
        return nyi();
      }

      /**
       * Removes an HTML attribute from one node, and adds it to another.
       *
       * @method attributeFollows
       * @param {String} name HTML attribute name
       * @param {HTMLElement} toElement New element to add the attribute to.
       * @param {HTMLElement} fromElement Old element to remove the attribute from.
       */
      attributeFollows(name, toElement, fromElement) {
        if (fromElement) {
          Polymer.dom(fromElement).removeAttribute(name);
        }
        if (toElement) {
          Polymer.dom(toElement).setAttribute(name, '');
        }
      }

      /**
       * Removes a class from one node, and adds it to another.
       *
       * @method classFollows
       * @param {String} name CSS class name
       * @param {HTMLElement} toElement New element to add the class to.
       * @param {HTMLElement} fromElement Old element to remove the class from.
       */
      classFollows(name, toElement, fromElement) {
        if (fromElement) {
          Polymer.dom(fromElement).classList.remove(name);
        }
        if (toElement) {
          Polymer.dom(toElement).classList.add(name);
        }
      }

      /**
       * Toggles an HTML attribute on or off.
       *
       * @method toggleAttribute
       * @param {String} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {HTMLElement=} node Node to target.  Defaults to `this`.
       */
      toggleAttribute(name, bool, node) {
        node = node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }


      /**
       * Toggles a CSS class on or off.
       *
       * @method toggleClass
       * @param {String} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {HTMLElement=} node Node to target.  Defaults to `this`.
       */
      toggleClass(name, bool, node) {
        node = node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      }

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @method transformText
       * @param {String} transform Transform setting.
       * @param {HTMLElement=} node Element to apply the transform to.
       * Defaults to `this`
       */
      transform(transformText, node) {
        node = node || this;
        node.style.webkitTransform = transformText;
        node.style.transform = transformText;
      }

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @method translate3d
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {HTMLElement=} node Element to apply the transform to.
       * Defaults to `this`.
       */
      translate3d(x, y, z, node) {
        node = node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

    }
  }

  Polymer.CompatElementMixin = Polymer.CachedMixin(CompatElementMixin);

  // bc
  Polymer.CompatElement = Polymer.CompatElementMixin(HTMLElement);
  Polymer.Base = Polymer.CompatElement.prototype;

})();
</script>
