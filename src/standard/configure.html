<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>

  /*
    Process inputs efficiently via a configure lifecycle callback.
    Configure is called top-down, host before local dom. Users should
    implement configure to supply a set of default values for the element by
    returning an object containing the properties and values to set.

    Configured values are not immediately set, instead they are set when
    an element becomes ready, after its local dom is ready. This ensures
    that any user change handlers are not called before ready time.

  */

  /*
  Implementation notes:

  Configured values are collected into _config. At ready time, properties
  are set to the values in _config. This ensures properties are set child
  before host and change handlers are called only at ready time. The host
  will reset a value already propagated to a child, but this is not
  inefficient because of dirty checking at the set point.

  Bind notification events are sent when properties are set at ready time
  and thus received by the host before it is ready. Since notifications result
  in property updates and this triggers side effects, handling notifications
  is deferred until ready time.

  In general, events can be heard before an element is ready. This may occur
  when a user sends an event in a change handler or listens to a data event
  directly (on-foo-changed).
  */

  (function() {

    var origPropertySetter = Polymer.Base._propertySetter;
    var origObserverEffect = Polymer.Base._observerEffect;
    var origComplexObserverEffect = Polymer.Base._complexObserverEffect;

    Polymer.Base._addFeature({

      // storage for configuration
      _setupConfigure: function(initialConfig) {
        this._config = {};
        // don't accept undefined values in intialConfig
        for (var i in initialConfig) {
          if (initialConfig[i] !== undefined) {
            this._config[i] = initialConfig[i];
          }
        }
        this._handlers = [];
      },

      // static attributes are deserialized into _config
      _marshalAttributes: function() {
        this._takeAttributesToModel(this._config);
      },

      // at configure time values are stored in _config
      _configValue: function(name, value) {
        this._config[name] = value;
      },

      // Override polymer-mini thunk
      _beforeClientsReady: function() {
        this._configure();
      },

      // configure: returns user supplied default property values
      // combines with _config to create final property values
      _configure: function() {
        // some annotation data needs to be handed from host to client
        // e.g. hand template content stored in notes to children as part of
        // configure flow so templates have their content at ready time
        this._configureAnnotationReferences();
        // save copy of configuration that came from above
        this._aboveConfig = this.mixin({}, this._config);
        // get individual default values from property configs
        var config = {};
        // mixed-in behaviors
        this.behaviors.forEach(function(b) {
          this._configureProperties(b.properties, config);
        }, this);
        // prototypical behavior
        this._configureProperties(this.properties, config);
        // override local configuration with configuration from above
        this._mixinConfigure(config, this._aboveConfig);
        // this is the new _config, which are the final values to be applied
        this._config = config;
        // pass configuration data to bindings
        this._executeStaticEffects();
        this._applyConfig(this._config, this._aboveConfig);
      },

      _configureProperties: function(properties, config) {
        for (var i in properties) {
          var c = properties[i];
          // don't accept undefined values
          if (c.value !== undefined) {
            var value = c.value;
            if (typeof value == 'function') {
              // pass existing config values (this._config) to value function
              value = value.call(this, this._config);
            }
            config[i] = value;
          }
        }
      },

      _mixinConfigure: function(a, b) {
        for (var prop in b) {
          if (!this.getPropertyInfo(prop).readOnly) {
            a[prop] = b[prop];
          }
        }
      },

      // Override polymer-mini thunk
      _afterClientsReady: function() {
        this._executeObservers();
      },

      // NOTE: values are already propagated to children via
      // _distributeConfig so propagation triggered by effects here is
      // redundant, but safe due to dirty checking
      _applyConfig: function(config, aboveConfig) {
        for (var n in config) {
          // Don't stomp on values that may have been set by other side effects
          if (this[n] === undefined) {
            // Call _propertySet for any properties with accessors, which will
            // initialize read-only properties also; set quietly if value was
            // configured from above, as opposed to default
            this.__setProperty(n, config[n], n in aboveConfig);
          }
        }
        this._configured = true;
      },

      _executeObservers: function() {
        var fx$ = this._propertyEffects;
        if (fx$) {
          for (var p in fx$) {
            var fx = fx$[p];
            for (var i=0, l=fx.length, x; (i<l) && (x=fx[i]); i++) {
              var fn = this['_' + x.kind + 'Effect'];
              if (x.kind === 'observer') {
                var value = (p === x.effect.property) ? this[p] :
                  this.get(x.effect.property);
                fn.call(p, value, x);
              } else if (x.kind == 'complexObserver') {
                fn.call();
              }
            }
          }
        }
      },

      _propertySetter: function(property, value) {
        if (this._configured) {
          origPropertySetter.apply(this, arguments);
        } else {
          this._config[property] = value;
        }
      },

      _complexObserverEffect: function() {
        if (this._clientsReadied) {
          origObserverEffect.apply(this, arguments);
        }
      },

      _observerEffect: function() {
        if (this._clientsReadied) {
          origObserverEffect.apply(this, arguments);
        }
      }

    });

  })();

</script>