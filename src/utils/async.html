<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="boot.html">

<script>
(function(global) {

  'use strict';

  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
  let AsyncInterface;

  /**
   * A timer with the async interface.
   * @implements {AsyncInterface}
   */
  let timeOut = {
    run(fn, delay = 0) {
      return window.setTimeout(fn, delay);
    },
    cancel(handle) {
      window.clearTimeout(handle);
    }
  };

  /**
   * @param {number} wait
   * @return {!AsyncInterface}
   */
  timeOut.after = function(wait) {
    let after = {
      run(fn) {
        return window.setTimeout(fn, wait);
      },
      cancel: timeOut.cancel
    }
    return after;
  };

  /**
   * requestAnimationFrame with the async interface.
   * @implements {AsyncInterface}
   */
  let animationFrame = {
    run(fn) {
      return window.requestAnimationFrame(fn);
    },
    cancel(handle) {
      return window.cancelAnimationFrame(handle);
    }
  };

  /**
   * requestIdleCallback with the async interface.
   * @implements {AsyncInterface}
   */
  let idlePeriod = window.requestIdleCallback ? {
    run(fn) {
      return window.requestIdleCallback(fn);
    },
    cancel(handle) {
      return window.cancelIdleCallback(handle);
    }
  } : timeOut.after(16);

  /**
   * Micro task with the async interface.
   * @implements {AsyncInterface}
   */
  class MicroTask {
    constructor() {
      this._currVal = 0;
      this._lastVal = 0;
      this._callbacks = [];
      this._twiddleContent = 0;
      this._twiddle = document.createTextNode('');
      this.observer = new MutationObserver(() => {this._atEndOfMicrotask()});
      this.observer.observe(this._twiddle, {characterData: true});
    }
    run(callback) {
      this._twiddle.textContent = this._twiddleContent++;
      this._callbacks.push(callback);
      return this._currVal++;
    }
    cancel(handle) {
      const idx = handle - this._lastVal;
      if (idx >= 0) {
        if (!this._callbacks[idx]) {
          throw `invalid async handle: ${handle}`;
        }
        this._callbacks[idx] = null;
      }
    }
     _atEndOfMicrotask() {
      const len = this._callbacks.length;
      for (let i=0; i<len; i++) {
        let cb = this._callbacks[i];
        if (cb) {
          try {
            cb();
          } catch(e) {
            // Clear queue up to this point & start over after throwing
            i++;
            this._callbacks.splice(0, i);
            this._lastVal += i;
            this._twiddle.textContent = this._twiddleContent++;
            throw e;
          }
        }
      }
      this._callbacks.splice(0, len);
      this._lastVal += len;
    }
    flush() {
      this.observer.takeRecords();
      this._atEndOfMicrotask();
    }
  }

  /** @type {Object<string, !AsyncInterface>} */
  Polymer.Async = {
    timeOut,
    animationFrame,
    idlePeriod,
    microTask: new MicroTask()
  };
})(this);
</script>
