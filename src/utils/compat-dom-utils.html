<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="async.html">
<link rel="import" href="debounce.html">
<script>
(function() {

  // TODO(sorvell): figure out Polymer.dom compat...
  function decorateElement(e) {
    if (e.__polymerDecorated) {
      return e;
    }
    e.__polymerDecorated = true;

    e.observeNodes = function() {};

    e.unobserveNodes = function() {};

    e.deepContains = function(node) {
      if (this.contains(node)) {
        return true;
      }
      var n = node;
      var doc = node.ownerDocument;
      // walk from node to `this` or `document`
      while (n && n !== doc && n !== this) {
        // use logical parentnode, or native ShadowRoot host
        n = Polymer.dom(n).parentNode || n.host;
      }
      return n === this;
    };

    e.getOwnerRoot = function() {
      var n = this;
      while (n) {
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
          return n;
        }
        n = n.parentNode;
      }
    };

  }

  function decorateEvent(e) {
    if (e.__polymerDecorated) {
      return e;
    }
    e.__polymerDecorated = true;
    e.rootTarget = e.path[0];
    Object.defineProperty(e, 'localTarget', {
      get: function() {
        return e.target;
      }
    });
    return e;
  }

  Polymer.dom = function(obj) {
    obj = obj || document;
    if (obj instanceof Event) {
      decorateEvent(obj);
    } else {
      //var obj = obj.shadowRoot || obj;
      decorateElement(obj);
      if (window.ShadyDOM) {
        ShadyDOM.patch(obj);
      }
      // BREAKME(kschaaf): for short-term bc, but intend to break
      patchArrayMethods(obj);
    }
    return obj;
  };

  function patchArrayMethods(el) {
    ['querySelectorAll'].forEach(function(method) {
      var orig = el[method];
      el[method] = function() {
        return Array.from(orig.apply(this, arguments));
      }
    });
  }

  // TODO(sorvell): bc.
  Polymer.dom.flush = function() {
    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }
  }

  Polymer.Settings = {
    useShadow: true
  };

  Polymer.CompatStyleUtil = {
    prepStyleIncludes: function(dom, ownerDocument) {
      var s$ = dom.querySelectorAll('style[include]');
      for (var i=0, s; (i<s$.length) && (s=s$[i]); i++) {
        s.textContent = this.includeToCssText(s.getAttribute('include')) +
          s.textContent;
        s.removeAttribute('include');
        //Polymer.ResolveUrl.resolveCss(s.textContent, ownerDocument);
      }
    },

    includeToCssText: function(includes) {
      var cssText = '';
      var m$ = includes.trim().split(' ');
      for (var i=0, m; (i<m$.length) && (m=m$[i]); i++) {
        cssText += '\n/* begin include ' + m + ' */\n';
        cssText += this.cssFromModule(m);
        cssText += '\n/* end include ' + m + ' */\n';
      }
      return cssText;
    },

    cssFromModule: function(moduleId) {
      var m = Polymer.DomModule.import(moduleId);
      if (m && !m._cssText) {
        m._cssText = '';
        var template = m.querySelector('template');
        if (template) {
          var s$ = template.content.querySelectorAll('style');
          for (var i=0, s; (i<s$.length) && (s=s$[i]); i++) {
            m._cssText += s.textContent;
            var include = s.getAttribute('include');
            if (include) {
              m._cssText += this.includeToCssText(include);
            }
          }
        }
      }
      return m && m._cssText || '';
    },

    // TODO(kschaaf): remove, eventually
    normalizeForBC: function(node) {
      var self = this;
      Array.from(node.querySelectorAll('style')).forEach(function(s) {
        s.textContent = self.normalizeCSSTextForBC(s.textContent)
      });
    },
    normalizeCSSTextForBC: function(cssText) {
      return cssText.replace(/@apply\(([^;]*)\)(;|\n|$)/g, '@apply $1$2');
    }

  };

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      addEventListener('DOMContentLoaded', resolve);
    }
  }

})();
</script>
