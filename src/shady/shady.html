<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../utils/debounce.html">
<link rel="import" href="utils.html">
<link rel="import" href="array-splice.html">
<link rel="import" href="tree.html">
<!-- TODO(sorvell): notification...
<!-- <link rel="import" href="lib/dom-api-effective-nodes-observer.html"> -->
<!-- <link rel="import" href="lib/dom-api-distributed-nodes-observer.html"> -->
<link rel="import" href="distributor-v1.html">
<link rel="import" href="distributor-v0.html">
<link rel="import" href="patch.html">
<link rel="import" href="flush.html">
<script>

  (function() {

    var Tree = ShadyDom.Tree;

    /**
      Implements a pared down version of ShadowDOM's scoping, which is easy to
      polyfill across browsers.
    */
    class ShadyRoot {

      constructor(host, useV0) {
        if (!host) {
          throw 'Must provide a host';
        }
        var frag = document.createDocumentFragment();
        frag.__proto__ = ShadyFragmentMixin;
        frag._init(host, useV0);
        return frag;
      }

    }

    var ShadyMixin = {

      _init: function(host, useV0) {
        // TODO(sorvell): set a fake local name so this element can be
        // distinguished from a DocumentFragment when patching.
        // FF doesn't allow this to be `localName`
        this.__localName = 'ShadyRoot';
        // root <=> host
        host.shadyRoot = this;
        this.host = host;
        // logical dom setup
        Tree.Logical.saveChildNodes(host);
        Tree.Logical.saveChildNodes(this);
        // state flags
        this._clean = true;
        this._hasDistributed = false;
        this._distributor = useV0 ?
          new ShadyDom.DistributorV0(this) :
          new ShadyDom.DistributorV1(this);
        // TODO(sorvell): without calling update here,
        // initial distribution will not occur unless an element has been
        // TODO(sorvell): host state flags were set here next, needed?
      },

      // async render the "top" distributor (this is all that is needed to
      // distribute this host.
      update: function() {
        var distributionRoot = this._findDistributionRoot(this.host);
        //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);
        if (distributionRoot._clean) {
          distributionRoot._clean = false;
          //console.log('triggered render on', distributionRoot.host);
          distributionRoot.debounceRender()
          ShadyDom.addDebouncer(distributionRoot.debounceRender());
        }
      },

      // returns the host that's the top of this host's distribution tree
      _findDistributionRoot: function(element) {
        var root = element.shadyRoot;
        while (element && this._elementNeedsDistribution(element)) {
          root = ShadyDom.getRootNode(element);
          element = root && root.host;
        }
        return root;
      },

      // Return true if a host's children includes
      // an insertion point that selects selectively
      _elementNeedsDistribution: function(element) {
        var c$ = Tree.Logical.getChildNodes(element);
        for (var i=0, c; i < c$.length; i++) {
          c = c$[i];
          if (this._distributor.isInsertionPoint(c)) {
            return ShadyDom.getRootNode(element);
          }
        }
      },

      // async render this root!
      debounceRender: function() {
        this._renderDebouncer = ShadyDom.debounce(this._renderDebouncer,
          this.render, null, this);
        return this._renderDebouncer;
      },

      render: function() {
        //console.log('render', this.host);
        if (this._renderDebouncer) {
          this._renderDebouncer.cancel();
          this._renderDebouncer = null;
        }
        if (!this._clean) {
          // TODO(sorvell): updating insertion points is $ so optable
          if (!this._skipUpdateInsertionPoints) {
            this.updateInsertionPoints();
          }
          // logical
          this.distribute();
          // physical
          this.compose();
          // allow distributor to do post render tasks (e.g. fire events!)
          this._distributor.rendered();
          this._clean = true;
        }
      },

      forceRender: function() {
        this._clean = false;
        this.render();
      },

      distribute: function() {
        var dirtyRoots = this._distributor.distribute();
        for (var i=0, root; i<dirtyRoots.length; i++) {
          dirtyRoots[i].forceRender();
        }
      },

      updateInsertionPoints: function() {
        var i$ = this._insertionPoints = this._distributor.getInsertionPoints();
        // ensure insertionPoints's and their parents have logical dom info.
        // save logical tree info
        // a. for shadyRoot
        // b. for insertion points (fallback)
        // c. for parents of insertion points
        for (var i=0, c; i < i$.length; i++) {
          c = i$[i];
          Tree.Logical.saveChildNodes(c);
          Tree.Logical.saveChildNodes(Tree.Logical.getParentNode(c));
        }
      },

      get _insertionPoints() {
        if (!this.__insertionPoints) {
          this.updateInsertionPoints();
        }
        return this.__insertionPoints || (this.__insertionPoints = []);
      },

      set _insertionPoints(insertionPoints) {
        this.__insertionPoints = insertionPoints;
      },

      hasInsertionPoint: function() {
        return this._distributor.hasInsertionPoint();
      },

      compose: function() {
        // compose self
        // note: it's important to mark this clean before distribution
        // so that attachment that provokes additional distribution (e.g.
        // adding something to your parentNode) works
        this._composeTree();
        // TODO(sorvell): notification.
        // NOTE: send a signal to insertion points that we have distributed
        // which informs effective children observers
        //notifyContentObservers(this);
        // TODO(sorvell): See fast paths here in Polymer v1
        // (these seem unnecessary)
        // NOTE: send a signal to any observers
        // to report the initial set of childNodes
        if (!this._hasDistributed) {
          //notifyInitialDistribution(this.host);
        }
        this._hasDistributed = true;
      },

      // Reify dom such that it is at its correct rendering position
      // based on logical distribution.
      _composeTree: function() {
        this._updateChildNodes(this.host, this._composeNode(this.host));
        var p$ = this._insertionPoints || [];
        for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {
          parent = Tree.Logical.getParentNode(p);
          if ((parent !== this.host) && (parent !== this)) {
            this._updateChildNodes(parent, this._composeNode(parent));
          }
        }
      },

      // Returns the list of nodes which should be rendered inside `node`.
      _composeNode: function(node) {
        var children = [];
        var c$ = Tree.Logical.getChildNodes(node.shadyRoot || node);
        for (var i = 0; i < c$.length; i++) {
          var child = c$[i];
          if (this._distributor.isInsertionPoint(child)) {
            var distributedNodes = child._distributedNodes;
            for (var j = 0; j < distributedNodes.length; j++) {
              var distributedNode = distributedNodes[j];
              if (this.isFinalDestination(child, distributedNode)) {
                children.push(distributedNode);
              }
            }
          } else {
            children.push(child);
          }
        }
        return children;
      },

      isFinalDestination: function(insertionPoint, node) {
        return this._distributor.isFinalDestination(
          insertionPoint, node);
      },

      // Ensures that the rendered node list inside `container` is `children`.
      _updateChildNodes: function(container, children) {
        var composed = Tree.Composed.getChildNodes(container);
        var splices =
          ShadyDom.ArraySplice.calculateSplices(children, composed);
        // process removals
        for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {
          for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
            // check if the node is still where we expect it is before trying
            // to remove it; this can happen if we move a node and
            // then schedule its previous host for distribution resulting in
            // the node being removed here.
            if (Tree.Composed.getParentNode(n) === container) {
              Tree.Composed.removeChild(container, n);
            }
            composed.splice(s.index + d, 1);
          }
          d -= s.addedCount;
        }
        // process adds
        for (var i=0, s, next; (i<splices.length) && (s=splices[i]); i++) { //eslint-disable-line no-redeclare
          next = composed[s.index];
          for (j=s.index, n; j < s.index + s.addedCount; j++) {
            n = children[j];
            Tree.Composed.insertBefore(container, n, next);
            // TODO(sorvell): is this splice strictly needed?
            composed.splice(j, 0, n);
          }
        }
      },

      // TODO(sorvell): util
      getInsertionPointTag: function() {
        return this._distributor.insertionPointTag;
      }

    }

    var ShadyFragmentMixin = Object.create(DocumentFragment.prototype);
    ShadyDom.extend(ShadyFragmentMixin, ShadyMixin);

    // TODO(sorvell): observation...
    // function notifyContentObservers(root) {
    //   for (var i=0, c; i < root._insertionPoints.length; i++) {
    //     c = root._insertionPoints[i];
    //     if (DomApi.hasApi(c)) {
    //       Polymer.dom(c).notifyObserver();
    //     }
    //   }
    // }

    // function notifyInitialDistribution(host) {
    //   if (DomApi.hasApi(host)) {
    //     Polymer.dom(host).notifyObserver();
    //   }
    // }

    // var needsUpgrade = window.CustomElements && !CustomElements.useNative;

    // function upgradeLogicalChildren(children) {
    //   if (needsUpgrade && children) {
    //     for (var i=0; i < children.length; i++) {
    //       CustomElements.upgrade(children[i]);
    //     }
    //   }
    // }

    ShadyDom.isShadyRoot = function(obj) {
      return Boolean(obj.__localName === 'ShadyRoot');
    }

    ShadyDom.ShadyRoot = ShadyRoot;

  })();

</script>
