<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="innerHTML.html">
<script>
(function() {
  'use strict';

  var Tree = ShadyDom.Tree;
  var getInnerHTML = ShadyDom.getInnerHTML;

  var nativeCloneNode = Element.prototype.cloneNode;
  var nativeImportNode = Document.prototype.importNode;
  var nativeSetAttribute = Element.prototype.setAttribute;
  var nativeRemoveAttribute = Element.prototype.removeAttribute;
  var origAddEventListener = Element.prototype.addEventListener;
  var origRemoveEventListener = Element.prototype.removeEventListener;

  var mixinImpl = {

    // Try to add node. Record logical info, track insertion points, perform
    // distribution iff needed. Return true if the add is handled.
    addNode: function(container, node, ref_node) {
      var ownerRoot = this.ownerShadyRootForNode(container);
      if (ownerRoot) {
        // note: we always need to see if an insertion point is added
        // since this saves logical tree info; however, invalidation state
        // needs
        var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);
        // invalidate insertion points IFF not already invalid!
        // TODO(sorvell): this flipped to opt out.
        if (!ownerRoot._invalidInsertionPoints) {
          ownerRoot._invalidInsertionPoints = ipAdded;
        }
        this._addedNode(node, ownerRoot);
      }
      if (Tree.Logical.hasChildNodes(container)) {
        Tree.Logical.recordInsertBefore(node, container, ref_node);
      }
      // if not distributing and not adding to host, do a fast path addition
      var handled = this._maybeDistribute(node, container, ownerRoot) ||
        container.shadyRoot;
      // TODO(sorvell): Can we do this cleanup code before distribution?
      // if shady is handling this node,
      // the actual dom may not be removed if the node or fragment contents
      // remain undistributed so we ensure removal here.
      // NOTE: we only remove from existing location iff shady dom is involved.
      // This is because a node fragment is passed to the native add method
      // which expects to see fragment children. Regular elements must also
      // use this check because not doing so causes separation of
      // attached/detached and breaks, for example,
      // dom-if's attached/detached checks.
      if (handled) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          // TODO(sorvell): copy nodes ahead of time to avoid iloop
          // that can occur when parent is not patched and child is...
          var c$ = Tree.arrayCopyChildNodes(node);
          for (var i=0; i < c$.length; i++) {
            Tree.Composed.removeChild(node, c$[i]);
          }
        } else {
          var parent = Tree.Composed.getParentNode(node);
          if (parent) {
            Tree.Composed.removeChild(parent, node);
          }
        }
      }
      return handled;
    },

    // Try to remove node: update logical info and perform distribution iff
    // needed. Return true if the removal has been handled.
    // note that it's possible for both the node's host and its parent
    // to require distribution... both cases are handled here.
    removeNode: function(node) {
      // important that we want to do this only if the node has a logical parent
      var logicalParent = Tree.Logical.hasParentNode(node) &&
        Tree.Logical.getParentNode(node);
      var distributed;
      var ownerRoot = this.ownerShadyRootForNode(node);
      if (logicalParent) {
        // distribute node's parent iff needed
        distributed = this.maybeDistributeParent(node);
        Tree.Logical.recordRemoveChild(node, logicalParent);
        // remove node from root and distribute it iff needed
        if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||
          logicalParent.localName === ownerRoot.getInsertionPointTag())) {
          // TODO(sorvell): invalidation flipped
          ownerRoot._invalidInsertionPoints = true;
          ownerRoot.update();
        }
      }
      this._removeOwnerShadyRoot(node);
      if (ownerRoot) {
        this._removedNode(node, ownerRoot);
      }
      return distributed;
    },

    removeNodeFromParent: function(node, parent) {
      if (parent) {
        // TODO(sorvell): notify
        // if (DomApi.hasApi(parent)) {
        //   dom(parent).notifyObserver();
        // }
        this.removeNode(node);
      } else {
        this._removeOwnerShadyRoot(node);
      }
    },

    _hasCachedOwnerRoot: function(node) {
      return Boolean(node.__ownerShadyRoot !== undefined);
    },

    ownerRootForNode: function(node) {
      if (!node) {
        return;
      }
      var root = node.__ownerShadyRoot;
      if (root === undefined) {
        if (ShadyDom.isShadyRoot(node)) {
          root = node;
        } else {
          var parent = Tree.Logical.getParentNode(node);
          root = parent ? this.ownerRootForNode(parent) : node;
        }
        // memo-ize result for performance but only memo-ize
        // result if node is in the document. This avoids a problem where a root
        // can be cached while an element is inside a fragment.
        // If this happens and we cache the result, the value can become stale
        // because for perf we avoid processing the subtree of added fragments.
        if (document.documentElement.contains(node)) {
          node.__ownerShadyRoot = root;
        }
      }
      return root;
    },

    ownerShadyRootForNode: function(node) {
      var root = this.ownerRootForNode(node);
      if (ShadyDom.isShadyRoot(root)) {
        return root;
      }
    },

    _maybeDistribute: function(node, container, ownerRoot) {
      // TODO(sorvell): technically we should check non-fragment nodes for
      // <content> children but since this case is assumed to be exceedingly
      // rare, we avoid the cost and will address with some specific api
      // when the need arises.  For now, the user must call
      // distributeContent(true), which updates insertion points manually
      // and forces distribution.
      var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';
      var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&
        !node.__noContent &&
        insertionPointTag && node.querySelector(insertionPointTag);
      var wrappedContent = fragContent &&
        (Tree.Logical.getParentNode(fragContent).nodeType !==
        Node.DOCUMENT_FRAGMENT_NODE);
      var hasContent = fragContent || (node.localName === insertionPointTag);
      // There are 4 possible cases where a distribution may need to occur:
      // 1. ownerRoot has never distributed
      // 2. <content> being inserted (the host of the shady root where
      //    content is inserted needs distribution)
      // 3. children being inserted into parent with a shady root (parent
      //    needs distribution)
      // 4. container is an insertionPoint
      var needsInitialDistribution = ownerRoot && !ownerRoot._hasDistributed;
      if (needsInitialDistribution || hasContent ||
        (container.localName === insertionPointTag)) {
        if (ownerRoot) {
          // note, insertion point list update is handled after node
          // mutations are complete
          ownerRoot.update();
        }
      }
      var needsDist = this._nodeNeedsDistribution(container);
      if (needsDist) {
        container.shadyRoot.update();
      }
      // Return true when distribution will fully handle the composition
      // Note that if a content was being inserted that was wrapped by a node,
      // and the parent does not need distribution, return false to allow
      // the nodes to be added directly, after which children may be
      // distributed and composed into the wrapping node(s)
      return needsDist || (hasContent && !wrappedContent);
    },

    /* note: parent argument is required since node may have an out
    of date parent at this point; returns true if a <content> is being added */
    _maybeAddInsertionPoint: function(node, parent, root) {
      var added;
      var insertionPointTag = root.getInsertionPointTag();
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&
        !node.__noContent) {
        var c$ = node.querySelectorAll(insertionPointTag);
        for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {
          np = Tree.Logical.getParentNode(n);
          // don't allow node's parent to be fragment itself
          if (np === node) {
            np = parent;
          }
          na = this._maybeAddInsertionPoint(n, np, root);
          added = added || na;
        }
      } else if (node.localName === insertionPointTag) {
        Tree.Logical.saveChildNodes(parent);
        Tree.Logical.saveChildNodes(node);
        added = true;
      }
      return added;
    },

    _nodeNeedsDistribution: function(node) {
      return node && node.shadyRoot &&
        node.shadyRoot.hasInsertionPoint();
    },

    _addedNode: function(node, root) {
      if (ShadyDom.addedNode) {
        ShadyDom.addedNode(node, root);
      }
    },

    _removedNode: function(node, root) {
      if (ShadyDom.removedNode) {
        ShadyDom.removedNode(node, root);
      }
    },

    _removeDistributedChildren: function(root, container) {
      var hostNeedsDist;
      var ip$ = root._insertionPoints;
      for (var i=0; i<ip$.length; i++) {
        var insertionPoint = ip$[i];
        if (this._contains(container, insertionPoint)) {
          var dc$ = insertionPoint.getDistributedNodes();
          for (var j=0; j<dc$.length; j++) {
            hostNeedsDist = true;
            var node = dc$[j];
            var parent = Tree.Composed.getParentNode(node);
            if (parent) {
              Tree.Composed.removeChild(parent, node);
            }
          }
        }
      }
      return hostNeedsDist;
    },

    _contains: function(container, node) {
      while (node) {
        if (node == container) {
          return true;
        }
        node = Tree.Logical.getParentNode(node);
      }
    },

    _removeOwnerShadyRoot: function(node) {
      // optimization: only reset the tree if node is actually in a root
      if (this._hasCachedOwnerRoot(node)) {
        var c$ = Tree.Logical.getChildNodes(node);
        for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {
          this._removeOwnerShadyRoot(n);
        }
      }
      node.__ownerShadyRoot = undefined;
    },

    // TODO(sorvell): This will fail if distribution that affects this
    // question is pending; this is expected to be exceedingly rare, but if
    // the issue comes up, we can force a flush in this case.
    firstComposedNode: function(insertionPoint) {
      var n$ = insertionPoint.getDistributedNodes();
      var root = this.ownerRootForNode(insertionPoint);
      for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
        // means that we're composed to this spot.
        if (root.isFinalDestination(insertionPoint, n)) {
          return n;
        }
      }
    },

    clearNode: function(node) {
      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }
    },

    maybeDistributeParent: function(node) {
      var parent = Tree.Logical.getParentNode(node);
      if (this._nodeNeedsDistribution(parent)) {
        parent.shadyRoot.update();
        return true;
      }
    },

    maybeDistributeAttributeChange: function(node, name) {
      var distribute = (node.localName === 'content' && name === 'select') ||
        (node.localName === 'slot' && name === 'name');
      if (distribute) {
        var root = this.ownerRootForNode(node);
        if (root.update) {
          root.update();
        }
      }
    },

    _getComposedInnerHTML: function(node) {
      return getInnerHTML(node, true);
    },

    // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,
    // but it's also generally useful to recurse through the element tree
    // and is used by Polymer's styling system.
    query: function(node, matcher, halter) {
      var list = [];
      this._queryElements(Tree.Logical.getChildNodes(node), matcher,
        halter, list);
      return list;
    },

    _queryElements: function(elements, matcher, halter, list) {
      for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE &&
            this._queryElement(c, matcher, halter, list)) {
          return true;
        }
      }
    },

    _queryElement: function(node, matcher, halter, list) {
      var result = matcher(node);
      if (result) {
        list.push(node);
      }
      if (halter && halter(result)) {
        return result;
      }
      this._queryElements(Tree.Logical.getChildNodes(node), matcher,
        halter, list);
    },

    activeElementForNode: function(node) {
      var active = document.activeElement;
      if (!active) {
        return null;
      }
      var isShadyRoot = !!(ShadyDom.isShadyRoot(node));
      if (node !== document) {
        // If this node isn't a document or shady root, then it doesn't have
        // an active element.
        if (!isShadyRoot) {
          return null;
        }
        // If this shady root's host is the active element or the active
        // element is not a descendant of the host (in the composed tree),
        // then it doesn't have an active element.
        if (node.host === active ||
            !node.host.contains(active)) {
          return null;
        }
      }
      // This node is either the document or a shady root of which the active
      // element is a (composed) descendant of its host; iterate upwards to
      // find the active element's most shallow host within it.
      var activeRoot = this.ownerShadyRootForNode(active);
      while (activeRoot && activeRoot !== node) {
        active = activeRoot.host;
        activeRoot = this.ownerShadyRootForNode(active);
      }
      if (node === document) {
        // This node is the document, so activeRoot should be null.
        return activeRoot ? null : active;
      } else {
        // This node is a non-document shady root, and it should be
        // activeRoot.
        return activeRoot === node ? active : null;
      }
    }

  };

  var NodeMixin = {
    getRootNode: function() {
      return mixinImpl.ownerRootForNode(this);
    }

  };

  Object.defineProperties(NodeMixin, {

    isConnected: {
      get() {
        return document.contains(this);
      },
      configurable: true
    },

    parentElement: {
      get() {
        return Tree.Logical.getParentNode(this);
      },
      configurable: true
    },

    parentNode: {
      get() {
        return Tree.Logical.getParentNode(this);
      },
      configurable: true
    },

    nextSibling: {
      get() {
        return Tree.Logical.getNextSibling(this);
      },
      configurable: true
    },

    previousSibling: {
      get() {
        return Tree.Logical.getPreviousSibling(this);
      },
      configurable: true
    },

    nextElementSibling: {
      get() {
        return Tree.Logical.getNextElementSibling(this);
      },
      configurable: true
    },

    previousElementSibling: {
      get() {
        return Tree.Logical.getPreviousElementSibling(this);
      },
      configurable: true
    },

    assignedSlot: {
      get() {
        return this._assignedSlot;
      },
      configurable: true
    }
  });

  var FragmentMixin = {

    appendChild: function(node) {
      return this.insertBefore(node);
    },

    // cases in which we may not be able to just do standard native call
    // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot
    // has an insertion point)
    // 2. container is a shadyRoot (don't distribute, instead set
    // container to container.host.
    // 3. node is <content> (host of container needs distribution)
    insertBefore: function(node, ref_node) {
      if (ref_node && Tree.Logical.getParentNode(ref_node) !== this) {
        throw Error('The ref_node to be inserted before is not a child ' +
          'of this node');
      }
      // remove node from its current position iff it's in a tree.
      if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
        var parent = Tree.Logical.getParentNode(node);
        mixinImpl.removeNodeFromParent(node, parent);
      }
      if (!mixinImpl.addNode(this, node, ref_node)) {
        if (ref_node) {
          // if ref_node is an insertion point replace with first distributed node
          // TODO(sorvell): v0/v1!!
          var root = mixinImpl.ownerShadyRootForNode(ref_node);
          if (root) {
            ref_node = ref_node.localName === root.getInsertionPointTag() ?
              mixinImpl.firstComposedNode(ref_node) : ref_node;
          }
        }
        // if adding to a shadyRoot, add to host instead
        var container = ShadyDom.isShadyRoot(this) ?
          this.host : this;
        if (ref_node) {
          Tree.Composed.insertBefore(container, node, ref_node);
        } else {
          Tree.Composed.appendChild(container, node);
        }
      }
      // TODO(sorvell): notify
      //this.notifyObserver();
      return node;
    },

    /**
      Removes the given `node` from the element's `lightChildren`.
      This method also performs dom composition.
    */
    removeChild: function(node) {
      if (Tree.Logical.getParentNode(node) !== this) {
        throw Error('The node to be removed is not a child of this node: ' +
          node);
      }
      if (!mixinImpl.removeNode(node)) {
        // if removing from a shadyRoot, remove form host instead
        var container = ShadyDom.isShadyRoot(this) ?
          this.host :
          this;
        // not guaranteed to physically be in container; e.g.
        // undistributed nodes.
        var parent = Tree.Composed.getParentNode(node);
        if (container === parent) {
          Tree.Composed.removeChild(container, node);
        }
      }
      // TODO(sorvell): notify
      //this.notifyObserver();
      return node;
    },

    replaceChild: function(node, ref_node) {
      this.insertBefore(node, ref_node);
      this.removeChild(ref_node);
      return node;
    },

    // TODO(sorvell): consider doing native QSA and filtering results.
    querySelector: function(selector) {
      // match selector and halt on first result.
      var result = mixinImpl.query(this, function(n) {
        return ShadyDom.matchesSelector(n, selector);
      }, function(n) {
        return Boolean(n);
      })[0];
      return result || null;
    },

    querySelectorAll: function(selector) {
      return mixinImpl.query(this, function(n) {
        return ShadyDom.matchesSelector(n, selector);
      });
    },

    cloneNode: function(deep) {
      var n = nativeCloneNode.call(this, false);
      if (deep) {
        var c$ = this.childNodes;
        for (var i=0, nc; i < c$.length; i++) {
          nc = c$[i].cloneNode(true);
          n.appendChild(nc);
        }
      }
      return n;
    },

    importNode: function(externalNode, deep) {
      // for convenience use this node's ownerDoc if the node isn't a document
      var doc = this instanceof Document ? this :
        this.ownerDocument;
      var n = nativeImportNode.call(doc, externalNode, false);
      if (deep) {
        var c$ = Tree.Logical.getChildNodes(externalNode);
        ShadyDom.patch(n);
        for (var i=0, nc; i < c$.length; i++) {
          nc = doc.importNode(c$[i], true);
          n.appendChild(nc);
        }
      }
      return n;
    }
  };

  Object.defineProperties(FragmentMixin, {

    childNodes: {
      get() {
        var c$ = Tree.Logical.getChildNodes(this);
        return Array.isArray(c$) ? c$ : Tree.arrayCopyChildNodes(this);
      },
      configurable: true
    },

    children: {
      get() {
        if (Tree.Logical.hasChildNodes(this)) {
          return Array.prototype.filter.call(this.childNodes, function(n) {
            return (n.nodeType === Node.ELEMENT_NODE);
          });
        } else {
          return Tree.arrayCopyChildren(this);
        }
      },
      configurable: true
    },

    firstChild: {
      get() {
        return Tree.Logical.getFirstChild(this);
      },
      configurable: true
    },

    lastChild: {
      get() {
        return Tree.Logical.getLastChild(this);
      },
      configurable: true
    },

    firstElementChild: {
      get() {
        return Tree.Logical.getFirstElementChild(this);
      },
      configurable: true
    },

    lastElementChild: {
      get() {
        return Tree.Logical.getLastElementChild(this);
      },
      configurable: true
    },

    // TODO(srovell): strictly speaking fragments do not have textContent
    // or innerHTML but ShadowRoots do and are not easily distinguishable.
    // textContent / innerHTML
    textContent: {
      get() {
        if (this.childNodes) {
          var tc = [];
          for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        }
        return '';
      },
      set(text) {
        mixinImpl.clearNode(this);
        if (text) {
          this.appendChild(document.createTextNode(text));
        }
      },
      configurable: true
    },

    innerHTML: {
      get() {
        return getInnerHTML(this);
      },
      set(text) {
        mixinImpl.clearNode(this);
        var d = document.createElement('div');
        d.innerHTML = text;
        // here, appendChild may move nodes async so we cannot rely
        // on node position when copying
        var c$ = Tree.arrayCopyChildNodes(d);
        for (var i=0; i < c$.length; i++) {
          this.appendChild(c$[i]);
        }
      },
      configurable: true
    }

  });

  var ElementMixin = {

    getDestinationInsertionPoints: function() {
      return this._destinationInsertionPoints || [];
    },

    // TODO(sorvell): should only exist on <content>
    getDistributedNodes: function() {
      return this._distributedNodes || [];
    },

    // TODO(sorvell): should only exist on <slot>
    assignedNodes: function(options) {
      return (options && options.flatten ? this._distributedNodes :
        this._assignedNodes) || [];
    },


    setAttribute: function(name, value) {
      nativeSetAttribute.call(this, name, value);
      if (!mixinImpl.maybeDistributeParent(this)) {
        mixinImpl.maybeDistributeAttributeChange(this, name);
      }
    },

    removeAttribute: function(name) {
      nativeRemoveAttribute.call(this, name);
      if (!mixinImpl.maybeDistributeParent(this)) {
        mixinImpl.maybeDistributeAttributeChange(this, name);
      }
    }

  };

  Object.defineProperties(ElementMixin, {

    shadowRoot: {
      get() {
        return this.shadyRoot;
      }
    },

    slot: {
      get() {
        return this.getAttribute('slot');
      },
      set(value) {
        this.setAttribute('slot', value);
      }
    }

  });

  var activeElementDescriptor = {
    get() {
      return mixinImpl.activeElementForNode(this);
    }
  }

  var ActiveElementMixin = {};
  Object.defineProperties(ActiveElementMixin, {
    activeElement: activeElementDescriptor
  });

  var UnderActiveElementMixin = {};
  Object.defineProperties(UnderActiveElementMixin, {
    _activeElement: activeElementDescriptor
  });

  var EventMixin = {

    __patched: 'Event',

    composedPath() {
      if (!this.__composedPath) {
        var composedPath = [];
        var current = this.__target;
        while (current) {
          composedPath.push(current);
          // BREAKME(sorvell): remove v0 support
          var contents = current.getDestinationInsertionPoints &&
            current.getDestinationInsertionPoints();
          if (contents && contents.length) {
            for (var i = 0; i < contents.length - 1; i++) {
              composedPath.push(contents[i]);
            }
            current = contents[contents.length - 1];
          } else if (current.assignedSlot) {
            current = current.assignedSlot;
          } else {
            current = current.parentNode || current.host;
          }
        }
        // event composedPath includes window in most recent native implementations
        composedPath.push(window);
        this.__composedPath = composedPath;
      }
      return this.__composedPath;
    },

    get target() {
      // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
      // shadow-including inclusive ancestor, return ANCESTOR.
      var base = this.currentTarget;
      var baseRoot = base && ShadyDom.ownerRootForNode(base);
      var p$ = this.composedPath();
      for (var i=0, ancestor, root; i < p$.length; i++) {
        ancestor = p$[i];
        root = ShadyDom.ownerRootForNode(ancestor);
        if (!ShadyDom.isShadyRoot(root) || root === baseRoot) {
          return ancestor;
        }
      }
    }

  };

  ShadyDom.addEventListener = function(type, fn, capture) {
    if (!this.__eventListenerCount) {
      this.__eventListenerCount = 0;
    }
    this.__eventListenerCount++;
    var wrappedFn = function(e) {
      if (!e.__target) {
        e.__target = e.target;
        var proto = ShadyDom.patchImpl.prototypeForObject(e);
        if (proto) {
          e.__proto__ = proto;
        }
      }
      return fn(e);
    }
    fn.__eventWrapper = wrappedFn;
    return origAddEventListener.call(this, type, wrappedFn, capture);
  };

  ShadyDom.removeEventListener = function(type, fn, capture) {
    var wrapper = fn.__eventWrapper;
    origRemoveEventListener.call(this, type, wrapper || fn, capture);
    if (wrapper) {
      fn.__eventWrapper = null;
      this.__eventListenerCount--;
    }
  };

  ShadyDom.Mixins = {

    Node: ShadyDom.extendAll({__patched: 'Node'}, NodeMixin),

    Fragment: ShadyDom.extendAll({__patched: 'Fragment'},
      NodeMixin, FragmentMixin, ActiveElementMixin),

    Element: ShadyDom.extendAll({__patched: 'Element'},
      NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),

    // Note: activeElement cannot be patched on document!
    Document: ShadyDom.extendAll({__patched: 'Document'},
      NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin),

    Event: EventMixin

  };
  ShadyDom.ownerRootForNode = mixinImpl.ownerRootForNode;

})();
</script>
