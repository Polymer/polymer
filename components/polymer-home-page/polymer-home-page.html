


<!--/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */-->
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
Polymer = {};
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */


// TODO(sorvell): this ensures Polymer is an object and not a function
// Platform is currently defining it as a function to allow for async loading
// of polymer; once we refine the loading process this likely goes away.
if (typeof window.Polymer === 'function') {
  Polymer = {};
}</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // copy own properties from 'api' to 'prototype, with name hinting for 'super'
  function extend(prototype, api) {
    if (prototype && api) {
      // use only own properties of 'api'
      Object.getOwnPropertyNames(api).forEach(function(n) {
        // acquire property descriptor
        var pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          // clone property via descriptor
          Object.defineProperty(prototype, n, pd);
          // cache name-of-method for 'super' engine
          if (typeof pd.value == 'function') {
            // hint the 'super' engine
            pd.value.nom = n;
          }
        }
      });
    }
    return prototype;
  }
  
  // exports

  scope.extend = extend;

})(Polymer);
</script>
<script>/* 
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(scope) {
  
  // usage
  
  // invoke cb.call(this) in 100ms, unless the job is re-registered,
  // which resets the timer
  // 
  // this.myJob = this.job(this.myJob, cb, 100)
  //
  // returns a job handle which can be used to re-register a job

  var Job = function(inContext) {
    this.context = inContext;
    this.boundComplete = this.complete.bind(this)
  };
  Job.prototype = {
    go: function(callback, wait) {
      this.callback = callback;
      var h;
      if (!wait) {
        h = requestAnimationFrame(this.boundComplete);
        this.handle = function() {
          cancelAnimationFrame(h);
        }
      } else {
        h = setTimeout(this.boundComplete, wait);
        this.handle = function() {
          clearTimeout(h);
        }
      }
    },
    stop: function() {
      if (this.handle) {
        this.handle();
        this.handle = null;
      }
    },
    complete: function() {
      if (this.handle) {
        this.stop();
        this.callback.call(this.context);
      }
    }
  };
  
  function job(job, callback, wait) {
    if (job) {
      job.stop();
    } else {
      job = new Job(this);
    }
    job.go(callback, wait);
    return job;
  }
  
  // exports 

  scope.job = job;
  
})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  var registry = {};

  HTMLElement.register = function(tag, prototype) {
    registry[tag] = prototype;
  }

  // get prototype mapped to node <tag>
  HTMLElement.getPrototypeForTag = function(tag) {
    var prototype = !tag ? HTMLElement.prototype : registry[tag];
    // TODO(sjmiles): creating <tag> is likely to have wasteful side-effects
    return prototype || Object.getPrototypeOf(document.createElement(tag));
  };

  // we have to flag propagation stoppage for the event dispatcher
  var originalStopPropagation = Event.prototype.stopPropagation;
  Event.prototype.stopPropagation = function() {
    this.cancelBubble = true;
    originalStopPropagation.apply(this, arguments);
  };
  
  // TODO(sorvell): remove when we're sure imports does not need
  // to load stylesheets
  /*
  HTMLImports.importer.preloadSelectors += 
      ', polymer-element link[rel=stylesheet]';
  */
})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
 (function(scope) {
    // super

    // `arrayOfArgs` is an optional array of args like one might pass
    // to `Function.apply`

    // TODO(sjmiles):
    //    $super must be installed on an instance or prototype chain
    //    as `super`, and invoked via `this`, e.g.
    //      `this.super();`

    //    will not work if function objects are not unique, for example,
    //    when using mixins.
    //    The memoization strategy assumes each function exists on only one 
    //    prototype chain i.e. we use the function object for memoizing)
    //    perhaps we can bookkeep on the prototype itself instead
    function $super(arrayOfArgs) {
      // since we are thunking a method call, performance is important here: 
      // memoize all lookups, once memoized the fast path calls no other 
      // functions
      //
      // find the caller (cannot be `strict` because of 'caller')
      var caller = $super.caller;
      // memoized 'name of method' 
      var nom = caller.nom;
      // memoized next implementation prototype
      var _super = caller._super;
      if (!_super) {
        if (!nom) {
          nom = caller.nom = nameInThis.call(this, caller);
        }
        if (!nom) {
          console.warn('called super() on a method not installed declaratively (has no .nom property)');
        }
        // super prototype is either cached or we have to find it
        // by searching __proto__ (at the 'top')
        _super = memoizeSuper(caller, nom, getPrototypeOf(this));
      }
      if (!_super) {
        // if _super is falsey, there is no super implementation
        //console.warn('called $super(' + nom + ') where there is no super implementation');
      } else {
        // our super function
        var fn = _super[nom];
        // memoize information so 'fn' can call 'super'
        if (!fn._super) {
          memoizeSuper(fn, nom, _super);
        }
        // invoke the inherited method
        // if 'fn' is not function valued, this will throw
        return fn.apply(this, arrayOfArgs || []);
      }
    }

    function nextSuper(proto, name, caller) {
      // look for an inherited prototype that implements name
      while (proto) {
        if ((proto[name] !== caller) && proto[name]) {
          return proto;
        }
        proto = getPrototypeOf(proto);
      }
    }

    function memoizeSuper(method, name, proto) {
      // find and cache next prototype containing `name`
      // we need the prototype so we can do another lookup
      // from here
      method._super = nextSuper(proto, name, method);
      if (method._super) {
        // _super is a prototype, the actual method is _super[name]
        // tag super method with it's name for further lookups
        method._super[name].nom = name;
      }
      return method._super;
    }

    function nameInThis(value) {
      var p = this.__proto__;
      while (p && p !== HTMLElement.prototype) {
        // TODO(sjmiles): getOwnPropertyNames is absurdly expensive
        var n$ = Object.getOwnPropertyNames(p);
        for (var i=0, l=n$.length, n; i<l && (n=n$[i]); i++) {
          var d = Object.getOwnPropertyDescriptor(p, n);
          if (typeof d.value === 'function' && d.value === value) {
            return n;
          }
        }
        p = p.__proto__;
      }
    }

    // NOTE: In some platforms (IE10) the prototype chain is faked via 
    // __proto__. Therefore, always get prototype via __proto__ instead of
    // the more standard Object.getPrototypeOf.
    function getPrototypeOf(prototype) {
      return prototype.__proto__;
    }

    // utility function to precompute name tags for functions
    // in a (unchained) prototype
    function hintSuper(prototype) {
      // tag functions with their prototype name to optimize
      // super call invocations
      for (var n in prototype) {
        var pd = Object.getOwnPropertyDescriptor(prototype, n);
        if (pd && typeof pd.value === 'function') {
          pd.value.nom = n;
        }
      }
    }

    // exports

    scope.super = $super;

})(Polymer);
</script>
<script>/* 
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(scope) {

  var typeHandlers = {
    string: function(value) {
      return value;
    },
    date: function(value) {
      return new Date(Date.parse(value) || Date.now());
    },
    boolean: function(value) {
      if (value === '') {
        return true;
      }
      return value === 'false' ? false : !!value;
    },
    number: function(value) {
      var n = parseFloat(value);
      // hex values like "0xFFFF" parseFloat as 0
      if (n === 0) {
        n = parseInt(value);
      }
      return isNaN(n) ? value : n;
      // this code disabled because encoded values (like "0xFFFF")
      // do not round trip to their original format
      //return (String(floatVal) === value) ? floatVal : value;
    },
    object: function(value, currentValue) {
      if (currentValue === null) {
        return value;
      }
      try {
        // If the string is an object, we can parse is with the JSON library.
        // include convenience replace for single-quotes. If the author omits
        // quotes altogether, parse will fail.
        return JSON.parse(value.replace(/'/g, '"'));
      } catch(e) {
        // The object isn't valid JSON, return the raw value
        return value;
      }
    },
    // avoid deserialization of functions
    'function': function(value, currentValue) {
      return currentValue;
    }
  };

  function deserializeValue(value, currentValue) {
    // attempt to infer type from default value
    var inferredType = typeof currentValue;
    // invent 'date' type value for Date
    if (currentValue instanceof Date) {
      inferredType = 'date';
    }
    // delegate deserialization via type string
    return typeHandlers[inferredType](value, currentValue);
  }

  // exports

  scope.deserializeValue = deserializeValue;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  var api = {};

  api.declaration = {};
  api.instance = {};

  // exports

  scope.api = api;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  var utils = {
    /**
      * Invokes a function asynchronously. The context of the callback
      * function is bound to 'this' automatically.
      * @method async
      * @param {Function|String} method
      * @param {any|Array} args
      * @param {number} timeout
      */
    async: function(method, args, timeout) {
      // when polyfilling Object.observe, ensure changes 
      // propagate before executing the async method
      Platform.flush();
      // second argument to `apply` must be an array
      args = (args && args.length) ? args : [args];
      // function to invoke
      var fn = function() {
        (this[method] || method).apply(this, args);
      }.bind(this);
      // execute `fn` sooner or later
      return timeout ? setTimeout(fn, timeout) : requestAnimationFrame(fn);
    },
    /**
      * Fire an event.
      * @method fire
      * @returns {Object} event
      * @param {string} type An event name.
      * @param {any} detail
      * @param {Node} onNode Target node.
      */
    fire: function(type, detail, onNode, bubbles, cancelable) {
      var node = onNode || this;
      var detail = detail || {};
      var event = new CustomEvent(type, {
        bubbles: (bubbles !== undefined ? bubbles : true), 
        cancelable: (cancelable !== undefined ? cancelable : true), 
        detail: detail
      });
      node.dispatchEvent(event);
      return event;
    },
    /**
      * Fire an event asynchronously.
      * @method asyncFire
      * @param {string} type An event name.
      * @param detail
      * @param {Node} toNode Target node.
      */
    asyncFire: function(/*inType, inDetail*/) {
      this.async("fire", arguments);
    },
    /**
      * Remove class from old, add class to anew, if they exist
      * @param classFollows
      * @param anew A node.
      * @param old A node
      * @param className
      */
    classFollows: function(anew, old, className) {
      if (old) {
        old.classList.remove(className);
      }
      if (anew) {
        anew.classList.add(className);
      }
    }
  };

  // no-operation function for handy stubs
  var nop = function() {};
  // null-object for handy stubs
  var nob = {};

  // deprecated

  utils.asyncMethod = utils.async;

  // exports

  scope.api.instance.utils = utils;
  scope.nop = nop;
  scope.nob = nob;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(scope) {

  // imports

  var log = window.logFlags || {};

  // magic words

  var EVENT_PREFIX = 'on-';
  var HANDLED_LIST = '__eventHandledList__';

  // instance events api

  var events = {
    // read-only
    EVENT_PREFIX: EVENT_PREFIX,
    // event name utilities
    hasEventPrefix: function (n) {
      return n && (n[0] === 'o') && (n[1] === 'n') && (n[2] === '-');
    },
    removeEventPrefix: function(n) {
      var suffix = n.slice(prefixLength);
      return events.event_translations[suffix] || suffix;
    },
    event_translations: {
      webkitanimationstart: 'webkitAnimationStart',
      webkitanimationend: 'webkitAnimationEnd',
      webkittransitionend: 'webkitTransitionEnd',
      domfocusout: 'DOMFocusOut',
      domfocusin: 'DOMFocusIn',
      dommousescroll: 'DOMMouseScroll'
    },
    // event listeners on host
    addHostListeners: function() {
      var events = this.eventDelegates;
      log.events && (Object.keys(events).length > 0) && console.log('[%s] addHostListeners:', this.localName, events);
      this.addNodeListeners(this, events, this.hostEventListener);
    },
    addNodeListeners: function(node, events, listener) {
      // note: conditional inside loop as optimization
      // for empty 'events' object
      var fn;
      for (var n in events) {
        if (!fn) {
          fn = listener.bind(this);
        }
        this.addNodeListener(node, n, fn);
      }
    },
    addNodeListener: function(node, event, listener) {
      node.addEventListener(event, listener);
    },
    hostEventListener: function(event) {
      if (!event.cancelBubble) {
        log.events && console.group("[%s]: hostEventListener(%s)", this.localName, event.type);
        var h = this.findEventDelegate(event);
        if (h) {
          log.events && console.log('[%s] found host handler name [%s]', this.localName, h);
          this.dispatchMethod(this, h, [event, event.detail, this]);
        }
        log.events && console.groupEnd();
      }
    },  
    // find the method name in delegates mapped to event.type
    findEventDelegate: function(event) {
      return this.eventDelegates[event.type];
    },
    // call 'method' or function method on 'obj' with 'args', if the method exists
    dispatchMethod: function(obj, method, args) {
      if (obj) {
        log.events && console.group('[%s] dispatch [%s]', obj.localName, method);
        var fn = typeof method === 'function' ? method : obj[method];
        if (fn) {
          fn[args ? 'apply' : 'call'](obj, args);
        }
        log.events && console.groupEnd();
        Platform.flush();
      }
    },
    //
    //  Bind events via attributes of the form on-eventName.
    //  This method hooks into the model syntax and does adds event listeners as
    //  needed. By default, binding paths are always method names on the root
    //  model, the custom element in which the node exists. Adding a '@' in the
    //  path directs the event binding to use the model path as the event listener.
    //  In both cases, the actual listener is attached to a generic method which
    //  evaluates the bound path at event execution time. 
    //
    prepareBinding: function(path, name, node) {
      // if lhs an event prefix,
      if (events.hasEventPrefix(name)) {
        // provide an event-binding callback
        return function(model, node) {
          log.events && console.log('event: [%s].%s => [%s].%s()"', node.localName, model.localName, path);
          var listener = function(event) {
            var ctrlr = findController(node);
            if (ctrlr && ctrlr.dispatchMethod) {
              var obj = ctrlr, method = path;
              if (path[0] == '@') {
                obj = model;
                method = Path.get(path.slice(1)).getValueFrom(model);
              }
              ctrlr.dispatchMethod(obj, method, [event, event.detail, node]);
            }
          };
          var eventName = events.removeEventPrefix(name);
          return {
            open: function() {
              node.addEventListener(eventName, listener, false);
            },
            close: function() {
              log.events && console.log('event.remove: [%s].%s => [%s].%s()"', node.localName, name, model.localName, path);
              node.removeEventListener(eventName, listener, false);
            },
            discardChanges: function() {}
          }
        };
      }
    }
  };

  var prefixLength = EVENT_PREFIX.length;

  function findController(node) {
    while (node.parentNode) {
      node = node.parentNode;
    }
    return node.host;
  };

  // exports

  scope.api.instance.events = events;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // instance api for attributes

  var attributes = {
    copyInstanceAttributes: function () {
      var a$ = this._instanceAttributes;
      for (var k in a$) {
        if (!this.hasAttribute(k)) {
          this.setAttribute(k, a$[k]);
        }
      }
    },
    // for each attribute on this, deserialize value to property as needed
    takeAttributes: function() {
      // if we have no publish lookup table, we have no attributes to take
      // TODO(sjmiles): ad hoc
      if (this._publishLC) {
        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {
          this.attributeToProperty(a.name, a.value);
        }
      }
    },
    // if attribute 'name' is mapped to a property, deserialize
    // 'value' into that property
    attributeToProperty: function(name, value) {
      // try to match this attribute to a property (attributes are
      // all lower-case, so this is case-insensitive search)
      var name = this.propertyForAttribute(name);
      if (name) {
        // filter out 'mustached' values, these are to be
        // replaced with bound-data and are not yet values
        // themselves
        if (value && value.search(scope.bindPattern) >= 0) {
          return;
        }
        // get original value
        var currentValue = this[name];
        // deserialize Boolean or Number values from attribute
        var value = this.deserializeValue(value, currentValue);
        // only act if the value has changed
        if (value !== currentValue) {
          // install new value (has side-effects)
          this[name] = value;
        }
      }
    },
    // return the published property matching name, or undefined
    propertyForAttribute: function(name) {
      var match = this._publishLC && this._publishLC[name];
      //console.log('propertyForAttribute:', name, 'matches', match);
      return match;
    },
    // convert representation of 'stringValue' based on type of 'currentValue'
    deserializeValue: function(stringValue, currentValue) {
      return scope.deserializeValue(stringValue, currentValue);
    },
    serializeValue: function(value, inferredType) {
      if (inferredType === 'boolean') {
        return value ? '' : undefined;
      } else if (inferredType !== 'object' && inferredType !== 'function'
          && value !== undefined) {
        return value;
      }
    },
    reflectPropertyToAttribute: function(name) {
      var inferredType = typeof this[name];
      // try to intelligently serialize property value
      var serializedValue = this.serializeValue(this[name], inferredType);
      // boolean properties must reflect as boolean attributes
      if (serializedValue !== undefined) {
        this.setAttribute(name, serializedValue);
        // TODO(sorvell): we should remove attr for all properties
        // that have undefined serialization; however, we will need to
        // refine the attr reflection system to achieve this; pica, for example,
        // relies on having inferredType object properties not removed as
        // attrs.
      } else if (inferredType === 'boolean') {
        this.removeAttribute(name);
      }
    }
  };

  // exports

  scope.api.instance.attributes = attributes;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // imports

  var log = window.logFlags || {};

  // magic words

  var OBSERVE_SUFFIX = 'Changed';

  // element api

  var empty = [];

  var properties = {
    observeProperties: function() {
      var n$ = this._observeNames, pn$ = this._publishNames;
      if ((n$ && n$.length) || (pn$ && pn$.length)) {
        var self = this;
        var o = this._propertyObserver = new CompoundObserver();
        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
          o.addPath(this, n);
          // observer array properties
          var pd = Object.getOwnPropertyDescriptor(this.__proto__, n);
          if (pd && pd.value) {
            this.observeArrayValue(n, pd.value, null);
          }
        }
        for (var i=0, l=pn$.length, n; (i<l) && (n=pn$[i]); i++) {
          if (!this.observe || (this.observe[n] === undefined)) {
            o.addPath(this, n);
          }
        }
        o.open(this.notifyPropertyChanges, this);
      }
    },
    notifyPropertyChanges: function(newValues, oldValues, paths) {
      var name, method, called = {};
      for (var i in oldValues) {
        // note: paths is of form [object, path, object, path]
        name = paths[2 * i + 1];
        if (this.publish[name] !== undefined) {
          this.reflectPropertyToAttribute(name);
        }
        method = this.observe[name];
        if (method) {
          this.observeArrayValue(name, newValues[i], oldValues[i]);
          if (!called[method]) {
            called[method] = true;
            // observes the value if it is an array
            this.invokeMethod(method, [oldValues[i], newValues[i], arguments]);
          }
        }
      }
    },
    observeArrayValue: function(name, value, old) {
      // we only care if there are registered side-effects
      var callbackName = this.observe[name];
      if (callbackName) {
        // if we are observing the previous value, stop
        if (Array.isArray(old)) {
          log.observe && console.log('[%s] observeArrayValue: unregister observer [%s]', this.localName, name);
          this.unregisterObserver(name + '__array');
        }
        // if the new value is an array, being observing it
        if (Array.isArray(value)) {
          log.observe && console.log('[%s] observeArrayValue: register observer [%s]', this.localName, name, value);
          var observer = new ArrayObserver(value);
          observer.open(function(value, old) {
            this.invokeMethod(callbackName, [old]);
          }, this);
          this.registerObserver(name + '__array', observer);
        }
      }
    },
    bindProperty: function(property, observable) {
      // apply Polymer two-way reference binding
      return bindProperties(this, property, observable);
    },
    unbindAllProperties: function() {
      if (this._propertyObserver) {
        this._propertyObserver.close();
      }
      this.unregisterObservers();
    },
    unbindProperty: function(name) {
      return this.unregisterObserver(name);
    },
    invokeMethod: function(method, args) {
      var fn = this[method] || method;
      if (typeof fn === 'function') {
        fn.apply(this, args);
      }
    },
    // bookkeeping observers for memory management
    registerObserver: function(name, observer) {
      var o$ = this._observers || (this._observers = {});
      o$[name] = observer;
    },
    unregisterObserver: function(name) {
      var o$ = this._observers;
      if (o$ && o$[name]) {
        o$[name].close();
        o$[name] = null;
        return true;
      }
    },
    unregisterObservers: function() {
      if (this._observers) {
        var keys=Object.keys(this._observers);
        for (var i=0, l=keys.length, k, o; (i < l) && (k=keys[i]); i++) {
          o = this._observers[k];
          o.close();
        }
        this._observers = {};
      }
    }
  };

  // property binding
  // bind a property in A to a path in B by converting A[property] to a
  // getter/setter pair that accesses B[...path...]
  function bindProperties(inA, inProperty, observable) {
    log.bind && console.log(LOG_BIND_PROPS, inB.localName || 'object', inPath, inA.localName, inProperty);
    // capture A's value if B's value is null or undefined,
    // otherwise use B's value
    // TODO(sorvell): need to review, can do with ObserverTransform
    var v = observable.discardChanges();
    if (v === null || v === undefined) {
      observable.setValue(inA[inProperty]);
    }
    return Observer.defineComputedProperty(inA, inProperty, observable);
  }

  // logging
  var LOG_OBSERVE = '[%s] watching [%s]';
  var LOG_OBSERVED = '[%s#%s] watch: [%s] now [%s] was [%s]';
  var LOG_CHANGED = '[%s#%s] propertyChanged: [%s] now [%s] was [%s]';
  var LOG_BIND_PROPS = "[%s]: bindProperties: [%s] to [%s].[%s]";

  // exports

  scope.api.instance.properties = properties;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // imports

  var log = window.logFlags || 0;
  var events = scope.api.instance.events;

  // expressionista

  // TODO(sorvell): we're patching the syntax while evaluating
  // event bindings. we'll move this to a better spot when that's done.
  var _prepareBinding = PolymerExpressions.prototype.prepareBinding;
  // <[node] [name] = {{path}}>
  PolymerExpressions.prototype.prepareBinding = function(path, name, node) {
    // if not an event, delegate to the standard syntax
    return events.prepareBinding(path, name, node)
        || _prepareBinding.call(this, path, name, node);
  };

  var syntax = new PolymerExpressions();

  // element api supporting mdv

  var mdv = {
    syntax: syntax,
    instanceTemplate: function(template) {
      return template.createInstance(this, this.syntax);
    },
    bind: function(name, observable) {
      // note: binding is a prepare signal. This allows us to be sure that any
      // property changes that occur as a result of binding will be observed.
      if (!this._elementPrepared) {
        this.prepareElement();
      }
      var property = this.propertyForAttribute(name);
      if (!property) {
        // TODO(sjmiles): this mixin method must use the special form
        // of `super` installed by `mixinMethod` in declaration/prototype.js
        return this.mixinSuper(arguments);
      } else {
        // clean out the closets
        this.unbind(name);
        // use n-way Polymer binding
        var observer = this.bindProperty(property, observable);
        // stick path on observer so it's available via this.bindings
        observer.path = observable.path_;
        // reflect bound property to attribute when binding
        // to ensure binding is not left on attribute if property
        // does not update due to not changing.
        this.reflectPropertyToAttribute(property);
        return this.bindings[name] = observer;
      }
    },
    asyncUnbindAll: function() {
      if (!this._unbound) {
        log.unbind && console.log('[%s] asyncUnbindAll', this.localName);
        this._unbindAllJob = this.job(this._unbindAllJob, this.unbindAll, 0);
      }
    },
    unbindAll: function() {
      if (!this._unbound) {
        this.unbindAllProperties();
        this.super();
        // unbind shadowRoot
        var root = this.shadowRoot;
        while (root) {
          unbindNodeTree(root);
          root = root.olderShadowRoot;
        }
        this._unbound = true;
      }
    },
    cancelUnbindAll: function(preventCascade) {
      if (this._unbound) {
        log.unbind && console.warn('[%s] already unbound, cannot cancel unbindAll', this.localName);
        return;
      }
      log.unbind && console.log('[%s] cancelUnbindAll', this.localName);
      if (this._unbindAllJob) {
        this._unbindAllJob = this._unbindAllJob.stop();
      }
      // cancel unbinding our shadow tree iff we're not in the process of
      // cascading our tree (as we do, for example, when the element is inserted).
      if (!preventCascade) {
        forNodeTree(this.shadowRoot, function(n) {
          if (n.cancelUnbindAll) {
            n.cancelUnbindAll();
          }
        });
      }
    }
  };

  function unbindNodeTree(node) {
    forNodeTree(node, _nodeUnbindAll);
  }

  function _nodeUnbindAll(node) {
    node.unbindAll();
  }

  function forNodeTree(node, callback) {
    if (node) {
      callback(node);
      for (var child = node.firstChild; child; child = child.nextSibling) {
        forNodeTree(child, callback);
      }
    }
  }

  var mustachePattern = /\{\{([^{}]*)}}/;

  // exports

  scope.bindPattern = mustachePattern;
  scope.api.instance.mdv = mdv;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {
  var preparingElements = 0;

  var base = {
    PolymerBase: true,
    job: Polymer.job,
    super: Polymer.super,
    // user entry point for element has had its createdCallback called
    created: function() {
    },
    // user entry point for element has shadowRoot and is ready for
    // api interaction
    ready: function() {
    },
    createdCallback: function() {
      this.created();
      if (this.ownerDocument.defaultView || this.alwaysPrepare ||
          preparingElements > 0) {
        this.prepareElement();
      }
    },
    // system entry point, do not override
    prepareElement: function() {
      this._elementPrepared = true;
      // install property observers
      this.observeProperties();
      // install boilerplate attributes
      this.copyInstanceAttributes();
      // process input attributes
      this.takeAttributes();
      // add event listeners
      this.addHostListeners();
      // guarantees that while preparing, any
      // sub-elements are also prepared
      preparingElements++;
      // process declarative resources
      this.parseDeclarations(this.__proto__);
      // decrement semaphore
      preparingElements--;
      // user entry point
      this.ready();
    },
    attachedCallback: function() {
      if (!this._elementPrepared) {
        this.prepareElement();
      }
      this.cancelUnbindAll(true);
      // invoke user action
      if (this.attached) {
        this.attached();
      }
      // TODO(sorvell): bc
      if (this.enteredView) {
        this.enteredView();
      }
    },
    detachedCallback: function() {
      if (!this.preventDispose) {
        this.asyncUnbindAll();
      }
      // invoke user action
      if (this.detached) {
        this.detached();
      }
      // TODO(sorvell): bc
      if (this.leftView) {
        this.leftView();
      }
    },
    // TODO(sorvell): bc
    enteredViewCallback: function() {
      this.attachedCallback();
    },
    // TODO(sorvell): bc
    leftViewCallback: function() {
      this.detachedCallback();
    },
    // TODO(sorvell): bc
    enteredDocumentCallback: function() {
      this.attachedCallback();
    },
    // TODO(sorvell): bc
    leftDocumentCallback: function() {
      this.detachedCallback();
    },
    // recursive ancestral <element> initialization, oldest first
    parseDeclarations: function(p) {
      if (p && p.element) {
        this.parseDeclarations(p.__proto__);
        p.parseDeclaration.call(this, p.element);
      }
    },
    // parse input <element> as needed, override for custom behavior
    parseDeclaration: function(elementElement) {
      var template = this.fetchTemplate(elementElement);
      if (template) {
        if (this.element.hasAttribute('lightdom')) {
          this.lightFromTemplate(template);
        } else {
          this.shadowFromTemplate(template);
        }
      }
    },
    // return a shadow-root template (if desired), override for custom behavior
    fetchTemplate: function(elementElement) {
      return elementElement.querySelector('template');
    },
    // utility function that creates a shadow root from a <template>
    shadowFromTemplate: function(template) {
      if (template) {
        // cache elder shadow root (if any)
        var elderRoot = this.shadowRoot;
        // make a shadow root
        var root = this.createShadowRoot();
        // migrate flag(s)
        root.resetStyleInheritance = this.resetStyleInheritance;
        // stamp template
        // which includes parsing and applying MDV bindings before being 
        // inserted (to avoid {{}} in attribute values)
        // e.g. to prevent <img src="images/{{icon}}"> from generating a 404.
        var dom = this.instanceTemplate(template);
        // append to shadow dom
        root.appendChild(dom);
        // perform post-construction initialization tasks on shadow root
        this.shadowRootReady(root, template);
        // return the created shadow root
        return root;
      }
    },
    // utility function that stamps a <template> into light-dom
    lightFromTemplate: function(template) {
      if (template) {
        // stamp template
        // which includes parsing and applying MDV bindings before being 
        // inserted (to avoid {{}} in attribute values)
        // e.g. to prevent <img src="images/{{icon}}"> from generating a 404.
        var dom = this.instanceTemplate(template);
        // append to shadow dom
        this.appendChild(dom);
        // perform post-construction initialization tasks on ahem, light root
        this.shadowRootReady(this, template);
        // return the created shadow root
        return dom;
      }
    },
    shadowRootReady: function(root, template) {
      // locate nodes with id and store references to them in this.$ hash
      this.marshalNodeReferences(root);
      // set up pointer gestures
      PointerGestures.register(root);
    },
    // locate nodes with id and store references to them in this.$ hash
    marshalNodeReferences: function(root) {
      // establish $ instance variable
      var $ = this.$ = this.$ || {};
      // populate $ from nodes with ID from the LOCAL tree
      if (root) {
        var n$ = root.querySelectorAll("[id]");
        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
          $[n.id] = n;
        };
      }
    },
    attributeChangedCallback: function(name, oldValue) {
      // TODO(sjmiles): adhoc filter
      if (name !== 'class' && name !== 'style') {
        this.attributeToProperty(name, this.getAttribute(name));
      }
      if (this.attributeChanged) {
        this.attributeChanged.apply(this, arguments);
      }
    },
    onMutation: function(node, listener) {
      var observer = new MutationObserver(function(mutations) {
        listener.call(this, observer, mutations);
        observer.disconnect();
      }.bind(this));
      observer.observe(node, {childList: true, subtree: true});
    }
  };

  // true if object has own PolymerBase api
  function isBase(object) {
    return object.hasOwnProperty('PolymerBase') 
  }

  // name a base constructor for dev tools

  function PolymerBase() {};
  PolymerBase.prototype = base;
  base.constructor = PolymerBase;
  
  // exports

  scope.Base = PolymerBase;
  scope.isBase = isBase;
  scope.api.instance.base = base;
  
})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // imports

  var log = window.logFlags || {};
  
  // magic words
  
  var STYLE_SCOPE_ATTRIBUTE = 'element';
  var STYLE_CONTROLLER_SCOPE = 'controller';
  
  var styles = {
    STYLE_SCOPE_ATTRIBUTE: STYLE_SCOPE_ATTRIBUTE,
    /**
     * Installs external stylesheets and <style> elements with the attribute 
     * polymer-scope='controller' into the scope of element. This is intended
     * to be a called during custom element construction. Note, this incurs a 
     * per instance cost and should be used sparingly.
     *
     * The need for this type of styling should go away when the shadowDOM spec
     * addresses these issues:
     * 
     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21391
     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21390
     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21389
     * 
     * @param element The custom element instance into whose controller (parent)
     * scope styles will be installed.
     * @param elementElement The <element> containing controller styles.
    */
    // TODO(sorvell): remove when spec issues are addressed
    installControllerStyles: function() {
      // apply controller styles, but only if they are not yet applied
      var scope = this.findStyleController();
      if (scope && !this.scopeHasElementStyle(scope, STYLE_CONTROLLER_SCOPE)) {
        // allow inherited controller styles
        var proto = getPrototypeOf(this), cssText = '';
        while (proto && proto.element) {
          cssText += proto.element.cssTextForScope(STYLE_CONTROLLER_SCOPE);
          proto = getPrototypeOf(proto);
        }
        if (cssText) {
          var style = this.element.cssTextToScopeStyle(cssText,
              STYLE_CONTROLLER_SCOPE);
          // TODO(sorvell): for now these styles are not shimmed
          // but we may need to shim them
          Polymer.applyStyleToScope(style, scope);
        }
      }
    },
    findStyleController: function() {
      if (window.ShadowDOMPolyfill) {
        return wrap(document.head);
      } else {
        // find the shadow root that contains this element
        var n = this;
        while (n.parentNode) {
          n = n.parentNode;
        }
        return n === document ? document.head : n;
      }
    },
    scopeHasElementStyle: function(scope, descriptor) {
      var rule = STYLE_SCOPE_ATTRIBUTE + '=' + this.localName + '-' + descriptor;
      return scope.querySelector('style[' + rule + ']');
    }
  };
  
  // NOTE: use raw prototype traversal so that we ensure correct traversal
  // on platforms where the protoype chain is simulated via __proto__ (IE10)
  function getPrototypeOf(prototype) {
    return prototype.__proto__;
  }

  // exports

  scope.api.instance.styles = styles;
  
})(Polymer);
</script>
<script>/* 
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(scope) {

var path = {
  resolveElementPaths: function(node) {
    pathResolver.resolvePathsInHTML(node);
  },
  addResolvePathApi: function() {
    var root = this.elementPath();
    // let assetpath attribute modify the resolve path
    var assetPath = this.getAttribute('assetpath') || '';
    var relPath = this.relPath;
    this.prototype.resolvePath = function(inPath, base) {
      if (base) {
        return this.element.urlToPath(base) + inPath;
      }
      var to = inPath;
      if (assetPath) {
        // assetPath is always a folder, drop the trailing '/'
        var from = assetPath.slice(0, -1);
        to = relPath(from, to);
      }
      return root + assetPath + to;
    };
  },
  elementPath: function() {
    return this.urlToPath(pathResolver.getDocumentUrl(this.ownerDocument));
  },
  relPath: function(from, to) {
    var fromParts = from.split('/');
    var toParts = to.split('/');

    // chop to common length
    var common = false;
    while(fromParts.length && toParts.length && fromParts[0] === toParts[0]) {
      fromParts.shift();
      toParts.shift();
      common = true;
    }

    // if there were some commonalities, add '../' for differences
    if (common) {
      for (var i = 0; i < fromParts.length; i++) {
        toParts.unshift('..');
      }
    }
    return toParts.join('/');
  },
  urlToPath: function(url) {
    if (!url) {
      return '';
    } else {
      var parts = url.split('/');
      parts.pop();
      parts.push('');
      return parts.join('/');
    }
  }
};

var URL_ATTRS = ['href', 'src', 'action'];
var URL_ATTRS_SELECTOR = '[' + URL_ATTRS.join('],[') + ']';
var URL_TEMPLATE_SEARCH = '{{.*}}';
var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
var CSS_IMPORT_REGEXP = /(@import[\s]*)([^;]*)(;)/g;

var pathResolver = {
  nodeUrl: function(node) {
    var docUrl = path.documentUrlFromNode(node);
    return pathResolver.resolveUrl(docUrl, path.hrefOrSrc(node));
    //return path.resolveUrl(path.documentURL, path.hrefOrSrc(node));
  },
  hrefOrSrc: function(node) {
    return node.getAttribute("href") || node.getAttribute("src");
  },
  documentUrlFromNode: function(node) {
    return pathResolver.getDocumentUrl(node.ownerDocument || node);
  },
  getDocumentUrl: function(doc) {
    var url = doc &&
        // TODO(sjmiles): ShadowDOMPolyfill intrusion
        (doc._URL || (doc.impl && doc.impl._URL)
            || doc.baseURI || doc.URL)
                || '';
    // take only the left side if there is a #
    return url.split('#')[0];
  },
  resolveUrl: function(baseUrl, url) {
    if (this.isAbsUrl(url)) {
      return url;
    }
    return this.compressUrl(this.urlToPath(baseUrl) + url);
  },
  resolveRelativeUrl: function(baseUrl, url) {
    if (this.isAbsUrl(url)) {
      return url;
    }
    return this.makeDocumentRelPath(this.resolveUrl(baseUrl, url));
  },
  isAbsUrl: function(url) {
    return /(^data:)|(^http[s]?:)|(^\/)/.test(url);
  },
  urlToPath: function(baseUrl) {
    var parts = baseUrl.split("/");
    parts.pop();
    parts.push('');
    return parts.join("/");
  },
  compressUrl: function(url) {
    var search = '';
    var searchPos = url.indexOf('?');
    // query string is not part of the path
    if (searchPos > -1) {
      search = url.substring(searchPos);
      url = url.substring(searchPos, 0);
    }
    var parts = url.split('/');
    for (var i=0, p; i<parts.length; i++) {
      p = parts[i];
      if (p === '..') {
        parts.splice(i-1, 2);
        i -= 2;
      }
    }
    return parts.join('/') + search;
  },
  makeDocumentRelPath: function(url) {
    // test url against document to see if we can construct a relative path
    pathResolver.urlElt.href = url;
    // IE does not set host if same as document
    if (!pathResolver.urlElt.host ||
        (!window.location.port && pathResolver.urlElt.port === '80') || 
        (pathResolver.urlElt.hostname === window.location.hostname &&
        pathResolver.urlElt.port === window.location.port &&
        pathResolver.urlElt.protocol === window.location.protocol)) {
      return this.makeRelPath(pathResolver.documentURL, pathResolver.urlElt.href);
    } else {
      return url;
    }
  },
  // make a relative path from source to target
  makeRelPath: function(source, target) {
    var s = source.split('/');
    var t = target.split('/');
    while (s.length && s[0] === t[0]){
      s.shift();
      t.shift();
    }
    for(var i = 0, l = s.length-1; i < l; i++) {
      t.unshift('..');
    }
    var r = t.join('/');
    return r;
  },
  makeAbsUrl: function(url) {
    pathResolver.urlElt.href = url;
    return pathResolver.urlElt.href;
  },
  resolvePathsInHTML: function(root, url) {
    url = url || pathResolver.documentUrlFromNode(root);
    if (root.hasAttributes && root.hasAttributes()) {
      pathResolver.resolveNodeAttributes(root, url);
    }
    pathResolver.resolveAttributes(root, url);
    pathResolver.resolveStyleElts(root, url);
    // handle template.content
    var templates = root.querySelectorAll('template');
    if (templates) {
      for (var i=0, l=templates.length, t; (i<l) && (t=templates[i]); i++) {
        if (t.content) {
          pathResolver.resolvePathsInHTML(t.content, url);
        }
      }
    }
  },
  resolvePathsInStylesheet: function(sheet) {
    var docUrl = pathResolver.nodeUrl(sheet);
    sheet.__resource = pathResolver.resolveCssText(sheet.__resource, docUrl);
  },
  resolveStyleElts: function(root, url) {
    var styles = root.querySelectorAll('style');
    if (styles) {
      for (var i=0, l=styles.length, s; (i<l) && (s=styles[i]); i++) {  
        pathResolver.resolveStyleElt(s, url);
      }
    }
  },
  resolveStyleElt: function(style, url) {
    url = url || pathResolver.documentUrlFromNode(style);
    style.textContent = pathResolver.resolveCssText(style.textContent, url);
  },
  resolveCssText: function(cssText, baseUrl) {
    var cssText = pathResolver.replaceUrlsInCssText(cssText, baseUrl, CSS_URL_REGEXP);
    return pathResolver.replaceUrlsInCssText(cssText, baseUrl, CSS_IMPORT_REGEXP);
  },
  replaceUrlsInCssText: function(cssText, baseUrl, regexp) {
    return cssText.replace(regexp, function(m, pre, url, post) {
      var urlPath = url.replace(/["']/g, '');
      urlPath = pathResolver.resolveRelativeUrl(baseUrl, urlPath);
      return pre + '\'' + urlPath + '\'' + post;
    });
  },
  resolveAttributes: function(root, url) {
    // search for attributes that host urls
    var nodes = root && root.querySelectorAll(URL_ATTRS_SELECTOR);
    if (nodes) {
      for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {  
        this.resolveNodeAttributes(n, url);
      }
    }
  },
  resolveNodeAttributes: function(node, url) {
    url = url || pathResolver.documentUrlFromNode(node);
    URL_ATTRS.forEach(function(v) {
      var attr = node.attributes[v];
      if (attr && attr.value &&
         (attr.value.search(URL_TEMPLATE_SEARCH) < 0)) {
        var urlPath = pathResolver.resolveRelativeUrl(url, attr.value);
        attr.value = urlPath;
      }
    });
  }
};

pathResolver.documentURL = pathResolver.getDocumentUrl(document);
pathResolver.urlElt = document.createElement('a');

// exports
scope.api.declaration.path = path;
scope.pathResolver = pathResolver;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // imports

  var log = window.logFlags || {};
  var api = scope.api.instance.styles;
  var STYLE_SCOPE_ATTRIBUTE = api.STYLE_SCOPE_ATTRIBUTE;

  // magic words

  var STYLE_SELECTOR = 'style';
  var STYLE_LOADABLE_MATCH = '@import';
  var SHEET_SELECTOR = 'link[rel=stylesheet]';
  var STYLE_GLOBAL_SCOPE = 'global';
  var SCOPE_ATTR = 'polymer-scope';

  var styles = {
    // returns true if resources are loading
    loadStyles: function(callback) {
      var content = this.templateContent();
      if (content) {
        this.convertSheetsToStyles(content);
      }
      var styles = this.findLoadableStyles(content);
      if (styles.length) {
        // if SD polyfill or opt-in, use xhr for cssText, otherwise
        // allow platform to cache styles.
        // TODO(sorvell): experimental flag to force direct caching of cssTest
        // rather than relying on platform to cache @import rules.
        if (window.ShadowDOMPolyfill || this.hasAttribute('cache-csstext')) {
          Platform.loader.xhrStyles(styles, callback);
        } else {
          Platform.loader.cacheStyles(styles, callback);
        }
      } else if (callback) {
        callback();
      }
    },
    convertSheetsToStyles: function(root) {
      var s$ = root.querySelectorAll(SHEET_SELECTOR);
      for (var i=0, l=s$.length, s, c; (i<l) && (s=s$[i]); i++) {
        c = createStyleElement(importRuleForSheet(s), s.ownerDocument);
        var scope = s.getAttribute(SCOPE_ATTR);
        if (scope) {
          c.setAttribute(SCOPE_ATTR, scope);
        }
        s.parentNode.replaceChild(c, s);
      }
    },
    findLoadableStyles: function(root) {
      var loadables = [];
      if (root) {
        var s$ = root.querySelectorAll(STYLE_SELECTOR);
        for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {
          if (s.textContent.match(STYLE_LOADABLE_MATCH)) {
            loadables.push(s);
          }
        }
      }
      return loadables;
    },
    /**
     * Install external stylesheets loaded in <polymer-element> elements into the 
     * element's template.
     * @param elementElement The <element> element to style.
     */
    // TODO(sorvell): wip... caching and styles handling can probably be removed
    // We need a scheme to ensure stylesheets are eagerly loaded without 
    // the creation of an element instance. Here are 2 options for handling this:
    // 1. create a dummy element with ShadowDOM in dom that includes ALL styles
    // processed here.
    // 2. place stylesheets outside the element template. This will allow 
    // imports to naturally load the sheets. Then at load time, we can remove
    // the stylesheet from dom.
    installSheets: function() {
      this.cacheSheets();
      this.cacheStyles();
      this.installLocalSheets();
      this.installGlobalStyles();
    },
    /**
     * Remove all sheets from element and store for later use.
     */
    cacheSheets: function() {
      this.sheets = this.findNodes(SHEET_SELECTOR);
      this.sheets.forEach(function(s) {
        if (s.parentNode) {
          s.parentNode.removeChild(s);
        }
      });
    },
    cacheStyles: function() {
      this.styles = this.findNodes(STYLE_SELECTOR + '[' + SCOPE_ATTR + ']');
      this.styles.forEach(function(s) {
        if (s.parentNode) {
          s.parentNode.removeChild(s);
        }
      });
    },
    /**
     * Takes external stylesheets loaded in an <element> element and moves
     * their content into a <style> element inside the <element>'s template.
     * The sheet is then removed from the <element>. This is done only so 
     * that if the element is loaded in the main document, the sheet does
     * not become active.
     * Note, ignores sheets with the attribute 'polymer-scope'.
     * @param elementElement The <element> element to style.
     */
    installLocalSheets: function () {
      var sheets = this.sheets.filter(function(s) {
        return !s.hasAttribute(SCOPE_ATTR);
      });
      var content = this.templateContent();
      if (content) {
        var cssText = '';
        sheets.forEach(function(sheet) {
          cssText += cssTextFromSheet(sheet) + '\n';
        });
        if (cssText) {
          var style = createStyleElement(cssText, this.ownerDocument);
          content.insertBefore(style, content.firstChild);
        }
      }
    },
    findNodes: function(selector, matcher) {
      var nodes = this.querySelectorAll(selector).array();
      var content = this.templateContent();
      if (content) {
        var templateNodes = content.querySelectorAll(selector).array();
        nodes = nodes.concat(templateNodes);
      }
      return matcher ? nodes.filter(matcher) : nodes;
    },
    templateContent: function() {
      var template = this.querySelector('template');
      return template && templateContent(template);
    },
    /**
     * Promotes external stylesheets and <style> elements with the attribute 
     * polymer-scope='global' into global scope.
     * This is particularly useful for defining @keyframe rules which 
     * currently do not function in scoped or shadow style elements.
     * (See wkb.ug/72462)
     * @param elementElement The <element> element to style.
    */
    // TODO(sorvell): remove when wkb.ug/72462 is addressed.
    installGlobalStyles: function() {
      var style = this.styleForScope(STYLE_GLOBAL_SCOPE);
      applyStyleToScope(style, document.head);
    },
    cssTextForScope: function(scopeDescriptor) {
      var cssText = '';
      // handle stylesheets
      var selector = '[' + SCOPE_ATTR + '=' + scopeDescriptor + ']';
      var matcher = function(s) {
        return matchesSelector(s, selector);
      };
      var sheets = this.sheets.filter(matcher);
      sheets.forEach(function(sheet) {
        cssText += cssTextFromSheet(sheet) + '\n\n';
      });
      // handle cached style elements
      var styles = this.styles.filter(matcher);
      styles.forEach(function(style) {
        cssText += style.textContent + '\n\n';
      });
      return cssText;
    },
    styleForScope: function(scopeDescriptor) {
      var cssText = this.cssTextForScope(scopeDescriptor);
      return this.cssTextToScopeStyle(cssText, scopeDescriptor);
    },
    cssTextToScopeStyle: function(cssText, scopeDescriptor) {
      if (cssText) {
        var style = createStyleElement(cssText);
        style.setAttribute(STYLE_SCOPE_ATTRIBUTE, this.getAttribute('name') +
            '-' + scopeDescriptor);
        return style;
      }
    }
  };

  function importRuleForSheet(sheet) {
    return '@import \'' + sheet.href + '\';';
  }

  function applyStyleToScope(style, scope) {
    if (style) {
      // TODO(sorvell): necessary for IE
      // see https://connect.microsoft.com/IE/feedback/details/790212/
      // cloning-a-style-element-and-adding-to-document-produces
      // -unexpected-result#details
      // var clone = style.cloneNode(true);
      var clone = createStyleElement(style.textContent);
      var attr = style.getAttribute(STYLE_SCOPE_ATTRIBUTE);
      if (attr) {
        clone.setAttribute(STYLE_SCOPE_ATTRIBUTE, attr);
      }
      scope.appendChild(clone);
    }
  }

  function createStyleElement(cssText, scope) {
    scope = scope || document;
    scope = scope.createElement ? scope : scope.ownerDocument;
    var style = scope.createElement('style');
    style.textContent = cssText;
    return style;
  }

  function cssTextFromSheet(sheet) {
    return (sheet && sheet.__resource) || '';
  }

  function matchesSelector(node, inSelector) {
    if (matches) {
      return matches.call(node, inSelector);
    }
  }
  var p = HTMLElement.prototype;
  var matches = p.matches || p.matchesSelector || p.webkitMatchesSelector 
      || p.mozMatchesSelector;
  
  // exports

  scope.api.declaration.styles = styles;
  scope.applyStyleToScope = applyStyleToScope;
  
})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(scope) {

  // imports

  var api = scope.api.instance.events;
  var log = window.logFlags || {};

  // polymer-element declarative api: events feature

  var events = { 
    parseHostEvents: function() {
      // our delegates map
      var delegates = this.prototype.eventDelegates;
      // extract data from attributes into delegates
      this.addAttributeDelegates(delegates);
    },
    addAttributeDelegates: function(delegates) {
      // for each attribute
      for (var i=0, a; a=this.attributes[i]; i++) {
        // does it have magic marker identifying it as an event delegate?
        if (api.hasEventPrefix(a.name)) {
          // extract the event name
          var event = api.removeEventPrefix(a.name);
          // extract the delegate name
          var delegate = a.value.replace('{{', '').replace('}}', '').trim();
          // add the info to delegates
          delegates[event] = delegate;
        }
      }
    }
  };

  // exports

  scope.api.declaration.events = events;

})(Polymer);</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // element api

  var properties = {
    inferObservers: function(prototype) {
      // called before prototype.observe is chained to inherited object
      var observe = prototype.observe, property;
      for (var n in prototype) {
        if (n.slice(-7) === 'Changed') {
          if (!observe) {
            observe  = (prototype.observe = {});
          }
          property = n.slice(0, -7)
          observe[property] = observe[property] || n;
        }
      }
    },
    explodeObservers: function(prototype) {
      // called before prototype.observe is chained to inherited object
      var o = prototype.observe;
      if (o) {
        var exploded = {};
        for (var n in o) {
          var names = n.split(' ');
          for (var i=0, ni; ni=names[i]; i++) {
            exploded[ni] = o[n];
          }
        }
        prototype.observe = exploded;
      }
    },
    optimizePropertyMaps: function(prototype) {
      if (prototype.observe) {
        // construct name list
        var a = prototype._observeNames = [];
        for (var n in prototype.observe) {
          var names = n.split(' ');
          for (var i=0, ni; ni=names[i]; i++) {
            a.push(ni);
          }
          //a.push(n);
        }
      }
      if (prototype.publish) {
        // construct name list
        var a = prototype._publishNames = [];
        for (var n in prototype.publish) {
          a.push(n);
        }
      }
    },
    publishProperties: function(prototype, base) {
      // if we have any properties to publish
      var publish = prototype.publish;
      if (publish) {
        // transcribe `publish` entries onto own prototype
        this.requireProperties(publish, prototype, base);
        // construct map of lower-cased property names
        prototype._publishLC = this.lowerCaseMap(publish);
      }
    },
    requireProperties: function(properties, prototype, base) {
      // ensure a prototype value for each property
      for (var n in properties) {
        if (prototype[n] === undefined && base[n] === undefined) {
          prototype[n] = properties[n];
        }
      }
    },
    lowerCaseMap: function(properties) {
      var map = {};
      for (var n in properties) {
        map[n.toLowerCase()] = n;
      }
      return map;
    }
  };

  // exports

  scope.api.declaration.properties = properties;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // magic words

  var ATTRIBUTES_ATTRIBUTE = 'attributes';
  var ATTRIBUTES_REGEX = /\s|,/;

  // attributes api

  var attributes = {
    inheritAttributesObjects: function(prototype) {
      // chain our lower-cased publish map to the inherited version
      this.inheritObject(prototype, 'publishLC');
      // chain our instance attributes map to the inherited version
      this.inheritObject(prototype, '_instanceAttributes');
    },
    publishAttributes: function(prototype, base) {
      // merge names from 'attributes' attribute
      var attributes = this.getAttribute(ATTRIBUTES_ATTRIBUTE);
      if (attributes) {
        // get properties to publish
        var publish = prototype.publish || (prototype.publish = {});
        // names='a b c' or names='a,b,c'
        var names = attributes.split(ATTRIBUTES_REGEX);
        // record each name for publishing
        for (var i=0, l=names.length, n; i<l; i++) {
          // remove excess ws
          n = names[i].trim();
          // do not override explicit entries
          if (n && publish[n] === undefined && base[n] === undefined) {
            publish[n] = null;
          }
        }
      }
    },
    // record clonable attributes from <element>
    accumulateInstanceAttributes: function() {
      // inherit instance attributes
      var clonable = this.prototype._instanceAttributes;
      // merge attributes from element
      var a$ = this.attributes;
      for (var i=0, l=a$.length, a; (i<l) && (a=a$[i]); i++) {  
        if (this.isInstanceAttribute(a.name)) {
          clonable[a.name] = a.value;
        }
      }
    },
    isInstanceAttribute: function(name) {
      return !this.blackList[name] && name.slice(0,3) !== 'on-';
    },
    // do not clone these attributes onto instances
    blackList: {
      name: 1,
      'extends': 1,
      constructor: 1,
      noscript: 1,
      assetpath: 1,
      'cache-csstext': 1
    }
  };

  // add ATTRIBUTES_ATTRIBUTE to the blacklist
  attributes.blackList[ATTRIBUTES_ATTRIBUTE] = 1;

  // exports

  scope.api.declaration.attributes = attributes;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // imports
  
  var api = scope.api;
  var isBase = scope.isBase;
  var extend = scope.extend;

  // prototype api

  var prototype = {
    register: function(name, extendee) {
      // build prototype combining extendee, Polymer base, and named api
      this.prototype = this.buildPrototype(name, extendee);
      // back reference declaration element
      // TODO(sjmiles): replace `element` with `elementElement` or `declaration`
      this.prototype.element = this;
      // more declarative features
      this.desugar(name, extendee);
      // register our custom element with the platform
      this.registerPrototype(name, extendee);
      // reference constructor in a global named by 'constructor' attribute
      this.publishConstructor();
    },
    buildPrototype: function(name, extendee) {
      // get our custom prototype (before chaining)
      var prototype = scope.getRegisteredPrototype(name);
      // get basal prototype
      var base = this.generateBasePrototype(extendee);
      // transcribe `attributes` declarations onto own prototype's `publish`
      this.publishAttributes(prototype, base);
      // `publish` properties to the prototype and to attribute watch
      this.publishProperties(prototype, base);
      // infer observers for `observe` list based on method names
      this.inferObservers(prototype);
      // desugar compound observer syntax, e.g. 'a b c' 
      this.explodeObservers(prototype);
      // chain various meta-data objects to inherited versions
      this.inheritMetaData(prototype, base);
      // chain custom api to inherited
      prototype = this.chainObject(prototype, base);
      // build side-chained lists to optimize iterations
      this.optimizePropertyMaps(prototype);
      // x-platform fixup
      ensurePrototypeTraversal(prototype);
      return prototype;
    },
    inheritMetaData: function(prototype, base) {
      // chain observe object to inherited
      this.inheritObject('observe', prototype, base);
      // chain publish object to inherited
      this.inheritObject('publish', prototype, base);
      // chain our lower-cased publish map to the inherited version
      this.inheritObject('_publishLC', prototype, base);
      // chain our instance attributes map to the inherited version
      this.inheritObject('_instanceAttributes', prototype, base);
      // chain our event delegates map to the inherited version
      this.inheritObject('eventDelegates', prototype, base);
    },
    // implement various declarative features
    desugar: function(name, extendee) {
      // install external stylesheets as if they are inline
      this.installSheets();
      // adjust any paths in dom from imports
      this.resolveElementPaths(this);
      // compile list of attributes to copy to instances
      this.accumulateInstanceAttributes();
      // parse on-* delegates declared on `this` element
      this.parseHostEvents();
      //
      this.adjustShadowElement();
      //
      // TODO(sorvell): install a helper method this.resolvePath to aid in 
      // setting resource paths. e.g.
      // this.$.image.src = this.resolvePath('images/foo.png')
      // Potentially remove when spec bug is addressed.
      // https://www.w3.org/Bugs/Public/show_bug.cgi?id=21407
      this.addResolvePathApi();
      // under ShadowDOMPolyfill, transforms to approximate missing CSS features
      if (window.ShadowDOMPolyfill) {
        Platform.ShadowCSS.shimStyling(this.templateContent(), name, extendee);
      }
      // allow custom element access to the declarative context
      if (this.prototype.registerCallback) {
        this.prototype.registerCallback(this);
      }
    },
    // TODO(sorvell): remove when spec addressed:
    // https://www.w3.org/Bugs/Public/show_bug.cgi?id=22460
    // make <shadow></shadow> be <shadow><content></content></shadow>
    adjustShadowElement: function() {
      // TODO(sorvell): avoid under SD polyfill until this bug is addressed:
      // https://github.com/Polymer/ShadowDOM/issues/297
      if (!window.ShadowDOMPolyfill) {
        var content = this.templateContent();
        if (content) {
          var s$ = content.querySelectorAll('shadow');
          for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {
            if (!s.children.length) {
              s.appendChild(document.createElement('content'));
            }
          }
        }
      }
    },
    // if a named constructor is requested in element, map a reference
    // to the constructor to the given symbol
    publishConstructor: function() {
      var symbol = this.getAttribute('constructor');
      if (symbol) {
        window[symbol] = this.ctor;
      }
    },
    // build prototype combining extendee, Polymer base, and named api
    generateBasePrototype: function(extnds) {
      var prototype = this.findBasePrototype(extnds);
      if (!prototype) {
        // create a prototype based on tag-name extension
        var prototype = HTMLElement.getPrototypeForTag(extnds);
        // insert base api in inheritance chain (if needed)
        prototype = this.ensureBaseApi(prototype);
        // memoize this base
        memoizedBases[extnds] = prototype;
      }
      return prototype;
    },
    findBasePrototype: function(name) {
      return memoizedBases[name];
    },
    // install Polymer instance api into prototype chain, as needed 
    ensureBaseApi: function(prototype) {
      if (prototype.PolymerBase) {
        return prototype;
      }
      var extended = Object.create(prototype);
      // we need a unique copy of base api for each base prototype
      // therefore we 'extend' here instead of simply chaining
      // we could memoize instead, especially for the common cases,
      // in particular, for base === HTMLElement.prototype
      for (var n in api.instance) {
        extend(extended, api.instance[n]);
      }
      // TODO(sjmiles): sharing methods across prototype chains is
      // not supported by our 'super' implementation which optimizes
      // by memoizing prototype relationships.
      // Probably we should have a version of 'extend' that is 
      // share-aware: it could study the text of each function,
      // look for usage of 'super', and wrap those functions in
      // closures.
      // As of now, there is only one problematic method, so 
      // we just patch it manually.
      // To avoid re-entrancy problems, the special super method
      // installed is called `mixinSuper` and the mixin method
      // must use this method instead of the default `super`.
      this.mixinMethod(extended, prototype, api.instance.mdv, 'bind');
      // return buffed-up prototype
      return extended;
    },
    mixinMethod: function(extended, prototype, api, name) {
      var $super = function(args) {
        return prototype[name].apply(this, args);
      };
      extended[name] = function() {
        this.mixinSuper = $super;
        return api[name].apply(this, arguments);
      }
    },
    // ensure prototype[name] inherits from a prototype.prototype[name]
    inheritObject: function(name, prototype, base) {
      // require an object
      var source = prototype[name] || {};
      // chain inherited properties onto a new object
      prototype[name] = this.chainObject(source, base[name]);
    },
    // register 'prototype' to custom element 'name', store constructor 
    registerPrototype: function(name, extendee) { 
      var info = {
        prototype: this.prototype
      }
      // native element must be specified in extends
      var typeExtension = this.findTypeExtension(extendee);
      if (typeExtension) {
        info.extends = typeExtension;
      }
      // register the custom type
      this.ctor = document.registerElement(name, info);
      // constructor shenanigans
      this.prototype.constructor = this.ctor;
      // register the prototype with HTMLElement for name lookup
      HTMLElement.register(name, this.prototype);
    }, 
    findTypeExtension: function(name) {
      if (name && name.indexOf('-') < 0) {
        return name;
      } else {
        var p = this.findBasePrototype(name);
        if (p.element) {
          return this.findTypeExtension(p.element.extends);
        }
      }
    }
  };

  // implementation of 'chainObject' depends on support for __proto__
  if (Object.__proto__) {
    prototype.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        object.__proto__ = inherited;
      }
      return object;
    }
  } else {
    prototype.chainObject = function(object, inherited) {
      if (object && inherited && object !== inherited) {
        var chained = Object.create(inherited);
        object = extend(chained, object);
      }
      return object;
    }
  }

  // memoize base prototypes
  memoizedBases = {};

  // On platforms that do not support __proto__ (version of IE), the prototype
  // chain of a custom element is simulated via installation of __proto__.
  // Although custom elements manages this, we install it here so it's
  // available during desugaring.
  function ensurePrototypeTraversal(prototype) {
    if (!Object.__proto__) {
      var ancestor = Object.getPrototypeOf(prototype);
      prototype.__proto__ = ancestor;
      if (isBase(ancestor)) {
        ancestor.__proto__ = Object.getPrototypeOf(ancestor);
      }
    }
  }

  // exports

  api.declaration.prototype = prototype;

})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  var queue = {
    // tell the queue to wait for an element to be ready
    wait: function(element) {
      if (this.indexOf(element) === -1 && 
          (flushQueue.indexOf(element) === -1)) {
        this.add(element);
      }
      return (this.indexOf(element) !== 0);
    },
    add: function(element) {
      //console.log('queueing', element.name);
      queueForElement(element).push(element);
    },
    indexOf: function(element) {
      var i = queueForElement(element).indexOf(element);
      if (i >= 0 && document.contains(element)) {
        i += (HTMLImports.useNative || HTMLImports.ready) ? importQueue.length :
            1e9;
      }
      return i;  
    },
    // tell the queue an element is ready to be registered
    register: function(element) {
      var readied = this.remove(element);
      if (readied) {
        flushQueue.push(readied);
        this.check();
      }
    },
    remove: function(element) {
      var i = this.indexOf(element);
      if (i !== 0) {
        //console.warn('queue order wrong', i);
        return;
      }
      return queueForElement(element).shift();  
    },
    check: function() {
      // next
      var element = this.nextElement();
      if (element) {
        element.registerWhenReady();
      }
      if (this.canFlush()) {
        this.flush();
        return true;
      }
    },
    nextElement: function() {
      return nextQueued();
    },
    canFlush: function() {
      return !this.waitToFlush && this.isEmpty();
    },
    isEmpty: function() {
      return !importQueue.length && !mainQueue.length;
    },
    flush: function() {
      // TODO(sorvell): As an optimization, turn off CE polyfill upgrading
      // while registering. This way we avoid having to upgrade each document
      // piecemeal per registration and can instead register all elements
      // and upgrade once in a batch. Without this optimization, upgrade time
      // degrades significantly when SD polyfill is used. This is mainly because
      // querying the document tree for elements is slow under the SD polyfill.
      CustomElements.ready = false;
      var element;
      while (flushQueue.length) {
        element = flushQueue.shift();
        element._register();
      }
      CustomElements.upgradeDocumentTree(document);
      CustomElements.ready = true;
      this.flushReadyCallbacks();
    },
    flushReadyCallbacks: function() {
      if (readyCallbacks) {
        var fn;
        while (readyCallbacks.length) {
          fn = readyCallbacks.shift();
          fn();
        }
      }
    },
    addReadyCallback: function(callback) {
      if (callback) {
        readyCallbacks.push(callback);
      }
    },
    waitToFlush: true
  };

  var importQueue = [];
  var mainQueue = [];
  var flushQueue = [];
  var readyCallbacks = [];

  function queueForElement(element) {
    return document.contains(element) ? mainQueue : importQueue;
  }

  function nextQueued() {
    return importQueue.length ? importQueue[0] : mainQueue[0];
  }

  var polymerReadied = false; 
  
  function whenPolymerReady(callback) {
    queue.waitToFlush = true;
    HTMLImports.whenImportsReady(function() {
      queue.addReadyCallback(callback);
      queue.waitToFlush = false;
      queue.check();
    });
  }

  // exports
  scope.queue = queue;
  scope.whenPolymerReady = whenPolymerReady;
})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  var whenPolymerReady = scope.whenPolymerReady;

  function importElements(elementOrFragment, callback) {
    if (elementOrFragment) {
      var ports = elementOrFragment.querySelectorAll('link[rel=import]');
      // normalize url...
      for (var i=0, l=ports.length, p; (i<l) && (p=ports[i]); i++) {
        p.href = p.href;
      }
      document.head.appendChild(elementOrFragment);
      whenPolymerReady(callback);
    } else if (callback) {
      callback();
    }
  }

  function importUrls(urls, callback) {
    if (urls && urls.length) {
        var frag = document.createDocumentFragment();
        for (var i=0, l=urls.length, url, link; (i<l) && (url=urls[i]); i++) {
          link = document.createElement('link');
          link.rel = 'import';
          link.href = url;
          frag.appendChild(link);
        }
        importElements(frag, callback);
    } else if (callback) {
      callback();
    }
  }

  // exports
  scope.import = importUrls;
  scope.importElements = importElements;
})(Polymer);
</script>
<script>/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope) {

  // imports

  var extend = scope.extend;
  var apis = scope.api.declaration;
  var queue = scope.queue;
  var whenPolymerReady = scope.whenPolymerReady;

  // imperative implementation: Polymer()

  // specify an 'own' prototype for tag `name`
  function element(name, prototype) {
    //console.log('registering prototype [' + name + ']');
    if (prototypesByName[name]) {
      throw 'Already registered prototype for element ' + name;
    }
    // cache the prototype
    prototypesByName[name] = prototype || {};
    // notify the registrar waiting for 'name', if any
    notifyPrototype(name);
  }

  // declarative implementation: <polymer-element>

  var prototype = extend(Object.create(HTMLElement.prototype), {
    createdCallback: function() {
      if (this.getAttribute('name')) {
        this.init();
      }
    },
    init: function() {
      // fetch the element name
      this.name = this.getAttribute('name');
      //console.log('createdCallback', this.name);
      // fetch our extendee name
      this.extends = this.getAttribute('extends');
      this.loadResources();
      this.registerWhenReady();
    },
    registerWhenReady: function() {
      if (this.registered) {
        return;
      }
      // if we have no prototype, wait
      if (this.waitingForPrototype(this.name)) {
        return;
      }
      if (this.waitingForQueue()) {
        return;
      }
      if (this.waitingForResources()) {
        return;
      }
      this.readyToRegister();
    },
    readyToRegister: function() {
      queue.register(this);
    },
    _register: function() {
      //console.log('registering', this.name);
      //console.group('registering', this.name);
      // warn if extending from a custom element not registered via Polymer
      if (isCustomTag(this.extends) && !isRegistered(this.extends)) {
        console.warn('%s is attempting to extend %s, an unregistered element ' +
            'or one that was not registered with Polymer.', this.name,
            this.extends);
      }

      this.register(this.name, this.extends);
      this.registered = true;
      registerRegistered(this.name);
      //console.groupEnd();
    },
    waitingForPrototype: function(name) {
      if (!getRegisteredPrototype(name)) {
        // then wait for a prototype
        waitPrototype[name] = this;
        // if explicitly marked as 'noscript'
        if (this.hasAttribute('noscript') && !this.noscript) {
          this.noscript = true;
          // TODO(sorvell): CustomElements polyfill awareness:
          // noscript elements should upgrade in logical order
          // script injection ensures this under native custom elements;
          // under imports + ce polyfills, scripts run before upgrades.
          // dependencies should be ready at upgrade time so register
          // prototype at this time.
          if (window.CustomElements && !CustomElements.useNative) {
            element(name);
          } else {
            var script = document.createElement('script');
            script.textContent = 'Polymer(\'' + name + '\');';
            this.appendChild(script);
          }
        }
        return true;
      }
    },
    waitingForResources: function() {
      return this._needsResources;
    },
    // NOTE: Elements must be queued in proper order for inheritance/composition
    // dependency resolution. Previously this was enforced for inheritance 
    // and by rule for composition. It's now entirely by rule.
    waitingForQueue: function() {
      return queue.wait(this);
    },
    loadResources: function() {
      this._needsResources = true;
      this.loadStyles(function() {
        this._needsResources = false;
        this.registerWhenReady();
      }.bind(this));
    }
  });

  // semi-pluggable APIs 
  // TODO(sjmiles): should be fully pluggable (aka decoupled, currently
  // the various plugins are allowed to depend on each other directly)
  Object.keys(apis).forEach(function(n) {
    extend(prototype, apis[n]);
  });

  // utility and bookkeeping

  // maps tag names to prototypes
  var prototypesByName = {};

  function getRegisteredPrototype(name) {
    return prototypesByName[name];
  }

  // elements waiting for prototype, by name
  var waitPrototype = {};

  function notifyPrototype(name) {
    if (waitPrototype[name]) {
      waitPrototype[name].registerWhenReady();
      delete waitPrototype[name];
    }
  }

  // track document.register'ed tag names
  var registered = {};

  function registerRegistered(name) {
    registered[name] = true;
  }

  function isRegistered(name) {
    return registered[name];
  }

  function isCustomTag(name) {
    return (name && name.indexOf('-') >= 0);
  }

  // exports
  scope.getRegisteredPrototype = getRegisteredPrototype;
  
  // namespace shenanigans so we can expose our scope on the registration 
  // function

  // TODO(sjmiles): find a way to do this that is less terrible
  // copy window.Polymer properties onto `element()`
  extend(element, scope);
  // make window.Polymer reference `element()`
  window.Polymer = element;

  // Under the HTMLImports polyfill, scripts in the main document
  // do not block on imports; we want to allow calls to Polymer in the main
  // document. We do so via coordination with Platform:
  var declarations = Platform.deliverDeclarations();
  if (declarations) {
    for (var i=0, l=declarations.length, d; (i<l) && (d=declarations[i]); i++) {
      element.apply(null, d);
    }
  }

  whenPolymerReady(function() {
    document.dispatchEvent(
      new CustomEvent('polymer-ready', {bubbles: true})
    );
  });

  // register polymer-element with document
  document.registerElement('polymer-element', {prototype: prototype});
})(Polymer);
</script>
<!--
 Copyright 2013 The Polymer Authors. All rights reserved.
 Use of this source code is governed by a BSD-style
 license that can be found in the LICENSE file.
-->
<!--<script src="polymer.js"></script>-->
  
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-flex-layout provides a helper to use CSS3 Flexible Boxes.  By putting
 * polymer-flex-layout inside an element it makes the element a flex
 * container. Use 'flex' attribute to make the flex item flexible.
 *
 * Example:
 *
 *     <div>
 *       <polymer-flex-layout></polymer-flex-layout>
 *       <div>Left</div>
 *       <div flex>Main</div>
 *       <div>Right</div>
 *     </div>
 *
 *     ---------------------------------
 *     |-------------------------------|
 *     ||Left|       Main       |Right||
 *     |-------------------------------|
 *     ---------------------------------
 *
 *     <div>
 *       <polymer-flex-layout vertical></polymer-flex-layout>
 *       <div>Header</div>
 *       <div flex>Body</div>
 *       <div>Footer</div>
 *     </div>
 *
 *     ----------
 *     ||------||
 *     ||Header||
 *     ||------||
 *     ||Body  ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||------||
 *     ||Footer||
 *     ||------||
 *     ----------
 *
 * @class polymer-flex-layout
 */
/**
 * If true, flex items are aligned vertically.
 *
 * @attribute vertical
 * @type boolean
 * @default false
 */
/**
 * Defines the default for how flex items are laid out along the cross axis on 
 * the current line.  Possible values are 'start', 'center' and 'end'.
 *
 * @attribute align
 * @type string
 * @default ''
 */
/**
 * Defines how flex items are laid out along the main axis on the current line.
 * Possible values are 'start', 'center' and 'end'.
 *
 * @attribute justify
 * @type string
 * @default ''
 */
/**
 * If true, polymer-flex-layout is the flex container.
 *
 * Example:
 *
 *     <polymer-flex-layout isContainer>
 *       <div>Left</div>
 *       <div flex>Main</div>
 *       <div>Right</div>
 *     </polymer-flex-layout>
 *
 *     ---------------------------------
 *     |-------------------------------|
 *     ||Left|       Main       |Right||
 *     |-------------------------------|
 *     ---------------------------------
 *
 * @attribute isContainer
 * @type boolean
 * @default false
 */
-->


<polymer-element name="polymer-flex-layout" attributes="vertical align justify isContainer" assetpath="../polymer-flex-layout/">
  <template>
    <style polymer-scope="controller">/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.flexbox, [flexbox], [h-flexbox], [v-flexbox] {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}

.flexbox.row, [flexbox], [h-flexbox] {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

.flexbox.column, [v-flexbox] {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

.flex, [flex], [fit] {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

::-webkit-distributed(.flex), 
::-webkit-distributed([flex]),
::-webkit-distributed([fit]) {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

.flexbox.align-start {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

.flexbox.align-end {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

.flexbox.align-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

.flexbox.justify-start {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

.flexbox.justify-end {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

.flexbox.justify-center {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

.flexbox.justify-between {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

:host(.flexbox:host, [flexbox]:host, [h-flexbox]:host, [v-flexbox]:host) {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}
  
:host(.flexbox.row:host, [flexbox]:host, [h-flexbox]:host) {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}
  
:host(.flexbox.column:host, [v-flexbox]:host) {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
  
:host(.flexbox.align-start:host) {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}
  
:host(.flexbox.align-end:host) {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

:host(.flexbox.align-center:host) {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

:host(.flexbox.justify-start:host) {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

:host(.flexbox.justify-end:host) {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

:host(.flexbox.justify-center:host) {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

:host(.flexbox.justify-between:host) {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}
</style>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.flexbox, [flexbox], [h-flexbox], [v-flexbox] {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}

.flexbox.row, [flexbox], [h-flexbox] {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

.flexbox.column, [v-flexbox] {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

.flex, [flex], [fit] {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

::-webkit-distributed(.flex), 
::-webkit-distributed([flex]),
::-webkit-distributed([fit]) {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

.flexbox.align-start {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

.flexbox.align-end {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

.flexbox.align-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

.flexbox.justify-start {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

.flexbox.justify-end {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

.flexbox.justify-center {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

.flexbox.justify-between {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

:host(.flexbox:host, [flexbox]:host, [h-flexbox]:host, [v-flexbox]:host) {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}
  
:host(.flexbox.row:host, [flexbox]:host, [h-flexbox]:host) {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}
  
:host(.flexbox.column:host, [v-flexbox]:host) {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
  
:host(.flexbox.align-start:host) {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}
  
:host(.flexbox.align-end:host) {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

:host(.flexbox.align-center:host) {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

:host(.flexbox.justify-start:host) {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

:host(.flexbox.justify-end:host) {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

:host(.flexbox.justify-center:host) {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

:host(.flexbox.justify-between:host) {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}
</style>
    <content></content>
  </template>
  <script>
    Polymer('polymer-flex-layout', {
      vertical: false,
      isContainer: false,
      layoutContainer: null,
      enteredView: function() {
        this.installControllerStyles();
        this.layoutContainer = this.isContainer ? 
            this : (this.parentNode.host || this.parentNode);
        this.verticalChanged();
        this.alignChanged();
        this.justifyChanged();
      },
      leftView: function() {
        this.layoutContainer = null;
      },
      layoutContainerChanged: function(old) {
        if (old) {
          old.classList.remove('flexbox');
        }
        this.style.display = this.layoutContainer === this ? '' : 'none';
        if (this.layoutContainer) {
          this.layoutContainer.classList.add('flexbox');
        }
      },
      switchContainerClass: function(prefix, old, name) {
        if (this.layoutContainer && name) {
          this.layoutContainer.classList.switch(
              prefix + old, prefix + name);
        }
      },
      verticalChanged: function() {
        if (this.layoutContainer) {
          this.layoutContainer.classList.toggle('column', this.vertical);
        }
      },
      alignChanged: function(old) {
        this.switchContainerClass('align-', old, this.align);
      },
      justifyChanged: function(old) {
        this.switchContainerClass('justify-', old, this.justify);
      }
    });
  </script>
</polymer-element>



<polymer-element name="polymer-grid-layout" attributes="nodes layout auto" assetpath="../polymer-grid-layout/">
  <template>
  </template>
  <script>
    (function() {
      Polymer('polymer-grid-layout', {
        nodes: null,
        layout: null,
        auto: false,
        created: function() {
          this.layout = [];
        },
        nodesChanged: function() {
          this.invalidate();
        },
        layoutChanged: function() {
          this.invalidate();
        },
        autoNodes: function() {
          this.nodes = this.parentNode.children.array().filter(
            function(node) {
              switch(node.localName) {
                case 'polymer-grid-layout':
                case 'style':
                  return false;
              }
              return true;
            }
          );
        },
        invalidate: function() {
          if (this.layout && this.layout.length) {
            // job debounces layout, only letting it occur every N ms
            this.layoutJob = this.job(this.layoutJob, this.relayout);
          }
        },
        relayout: function() {
          if (!this.nodes || this.auto) {
            this.autoNodes();
          }
          layout(this.layout, this.nodes);
          this.asyncFire('polymer-grid-layout');
        }
      });

      //

      var lineParent;

      function line(axis, p, d) {
        var l = document.createElement('line');
        var extent = (axis === 'left' ? 'width' : 
          (axis === 'top' ? 'height' : axis));
        l.setAttribute('extent', extent);
        if (d < 0) {
          axis = (axis === 'left' ? 'right' : 
            (axis === 'top' ? 'bottom' : axis));
        }
        p = Math.abs(p);
        l.style[axis] = p + 'px';
        l.style[extent] = '0px';
        lineParent.appendChild(l);
      }

      var colCount, colOwners, rowCount, rowOwners;

      function matrixillate(matrix) {
        // mesaure the matrix, must be rectangular
        rowCount = matrix.length;
        colCount = rowCount && matrix[0].length || 0;
        // transpose matrix
        var transpose = [];
        for (var i=0; i<colCount; i++) {
          var c = [];
          for (var j=0; j<rowCount; j++) {
            c.push(matrix[j][i]);
          }
          transpose.push(c);
        }
        // assign sizing control
        colOwners = findOwners(matrix);
        rowOwners = findOwners(transpose);
        //console.log('colOwners', colOwners);
        //console.log('rowOwners', rowOwners);
      }

      function findOwners(matrix) {
        var majCount = matrix.length;
        var minCount = majCount && matrix[0].length || 0;
        var owners = [];
        // for each column (e.g.)
        for (var i=0; i<minCount; i++) {
          // array of contained areas
          var contained = {};
          // look at each row to find a containing area
          for (var j=0; j<majCount; j++) {
            // get the row vector
            var vector = matrix[j]
            // node index at [i,j]
            var nodei = vector[i];
            // if a node is there
            if (nodei) {
              // determine if it bounds this column
              var owns = false;
              if (i === 0) {
                owns = (i === minCount-1) || (nodei !== vector[i+1]);
              } else if (i === minCount - 1) {
                owns = (i === 0) || (nodei !== vector[i-1]);
              } else {
                owns = nodei !== vector[i-1] && nodei !== vector[i+1];
              }
              if (owns) {
                contained[nodei] = 1;
              }
            }
            // store the owners for this column
            owners[i] = contained;
          }
        }
        return owners;
      }

      var nodes;

      function colWidth(i) {
        for (var col in colOwners[i]) {
          col = Number(col);
          if (col === 0) {
            return 96;
          }
          var node = nodes[col - 1];
          if (node.hasAttribute('h-flex') || node.hasAttribute('flex')) {
            return -1;
          }
          var w = node.offsetWidth;
          //console.log('colWidth(' + i + ') ==', w);
          return w;
        }
        return -1;
      }

      function rowHeight(i) {
        for (var row in rowOwners[i]) {
          row = Number(row);
          if (row === 0) {
            return 96;
          }
          var node = nodes[row - 1];
          if (node.hasAttribute('v-flex') || node.hasAttribute('flex')) {
            return -1;
          }
          var h = node.offsetHeight;
          //console.log('rowHeight(' + i + ') ==', h);
          return h;
        }
        return -1;
      }

      var m = 0;

      function railize(count, sizeFn) {
        //
        // create rails for `count` tracks using 
        // sizing function `sizeFn(trackNo)`
        //
        // for n tracks there are (n+1) rails
        //
        //   |track|track|track|
        //  0|->sz0|->sz1|<-sz2|0
        //
        //   |track|track|track|
        //  0|->sz0|     |<-sz2|0
        //
        // there can be one elastic track per set
        //
        //   |track|track|track|track|
        //  0|-->s0|-->s1|<--s1|<--s2|0
        //
        // sz1 spans multiple  tracks which makes
        // it elastic (it's underconstrained)
        //
        var rails = [];
        var a = 0;
        for (var i=0, x; i<count; i++) {
          rails[i] = {p: a, s: 1};
          x = sizeFn(i) + m + m;
          if (x == -1) {
            break;
          }
          a += x;
        }
        if (i === count) {
          rails[i] = {p: 0, s: -1};
        }
        var b = 0;
        for (var ii=count, x; ii>i; ii--) {
          rails[ii] = {p: b, s: -1};
          x = sizeFn(ii - 1) + m + m;
          if (x !== -1) {
            b += x;
          }
        }
        return rails;
      }

      // TODO(sjmiles): this code tries to preserve actual position,
      // so 'unposition' is really 'naturalize' or something
      function unposition(box) {
        var style = box.style;
        //style.right = style.bottom = style.width = style.height = '';
        style.position = 'absolute';
        style.display = 'inline-block';
        style.boxSizing = style.mozBoxSizing = 'border-box';
      }

      function _position(style, maj, min, ext, a, b) {
        style[maj] = style[min] = '';
        style[ext] = 'auto';
        if (a.s < 0 && b.s < 0) {
          var siz = a.p - b.p - m - m;
          style[ext] = siz + 'px';
          var c = 'calc(100% - ' + (b.p + siz + m) + 'px' + ')';
          style[maj] = '-webkit-' + c;
          style[maj] = c;
        } else if (b.s < 0) {
          style[maj] = a.p + m + 'px';
          style[min] = b.p + m + 'px';
        } else {
          style[maj] = a.p + m + 'px';
          style[ext] = b.p - a.p - m - m + 'px';
        }
      }

      function position(elt, left, right, top, bottom) {
        _position(elt.style, 'top', 'bottom', 'height', rows[top], 
            rows[bottom]);
        _position(elt.style, 'left', 'right', 'width', columns[left], 
            columns[right]);
      }

      function layout(matrix, anodes, alineParent) {
        //console.group('layout');

        lineParent = alineParent;
        nodes = anodes;
        matrixillate(matrix);

        nodes.forEach(unposition);

        columns = railize(colCount, colWidth);
        rows = railize(rowCount, rowHeight);

        if (alineParent) {
          //console.group('column rails');
          columns.forEach(function(c) {
            //console.log(c.p, c.s);
            line('left', c.p, c.s);
          });
          //console.groupEnd();

          //console.group('row rails');
          rows.forEach(function(r) {
            //console.log(r.p, r.s);
            line('top', r.p, r.s);
          });
          //console.groupEnd();
        }

        //console.group('rail boundaries');
        nodes.forEach(function(node, i) {
          // node indices are 1-based
          var n = i + 1;
          // boundary rails
          var l, r, t = 1e10, b = -1e10;
          matrix.forEach(function(vector, i) {
            var f = vector.indexOf(n);
            if (f > -1) {
              l = f;
              r = vector.lastIndexOf(n) + 1;
              t = Math.min(t, i);
              b = Math.max(b, i) + 1;
            }
          });
          if (l == undefined) {
            //console.log('unused');
            node.style.position = 'absolute';
            var offscreen = node.getAttribute('offscreen');
            switch (offscreen) {
              case 'basement':
                node.style.zIndex = 0;
                break;
              case 'left':
              case 'top':
                node.style[offscreen] = node.offsetWidth * -2 + 'px';
                break;
              case 'right':
                node.style.left = node.offsetParent.offsetWidth 
                    + node.offsetWidth + 'px';
                break;
              case 'bottom':
                node.style.top = node.parentNode.offsetHeight 
                    + node.offsetHeight + 'px';
                break;
              default:
                node.style[Math.random() >= 0.5 ? 'left' : 'top'] = '-110%';
            }
            //node.style.opacity = 0;
            node.style.pointerEvents = 'none';
          } else {
            node.style.pointerEvents = '';
            //node.style.opacity = '';
            //console.log(l, r, t, b);
            position(node, l, r, t, b);
          }
        });
        //console.groupEnd();
        //console.groupEnd();
      }

    })();
  </script>
</polymer-element>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
-->
<!--
/**
 * The polymer-selection element is used to manage selection state. It has no
 * visual appearance and is typically used in conjuneciton with another element.
 * For example, <a href="polymer-selector.html">polymer-selector</a>
 * use a polymer-selection to manage selection.
 *
 * To mark an item as selected, call the select(item) method on 
 * polymer-selection. Notice that the item itself is an argument to this method.
 * The polymer-selection element manages selection state for any given set of
 * items. When an item is selected, the `polymer-select` event is fired.
 * The attribute "multi" indicates if multiple items can be selected at once.
 * 
 * Example:
 *
 *     <polymer-element name="selection-example">
 *        <template>
 *          <style>
 *            ::-webkit-distributed(> .selected) {
 *              font-weight: bold;
 *              font-style: italic;
 *            }
 *          </style>
 *          <ul on-tap="{{itemTapAction}}">
 *            <content></content>
 *          </ul>
 *          <polymer-selection id="selection" multi on-polymer-select="{{selectAction}}"></polymer-selection>
 *        </template>
 *        <script>
 *          Polymer('selection-example', {
 *            itemTapAction: function(e) {
 *              this.$.selection.select(e.target);
 *            },
 *            selectAction: function(e, detail) {
 *              detail.item.classList.toggle('selected', detail.isSelected);
 *            }
 *          });
 *        </script>
 *     </polymer-element>
 *
 *     <selection-example>
 *       <li>Red</li>
 *       <li>Green</li>
 *       <li>Blue</li>
 *     </selection-example>
 *
 * @class polymer-selection
 */
 /**
 * Fired when an item's selection state is changed. This event is fired both
 * when an item is selected or deselected. The `isSelected` detail property
 * contains the selection state.
 * 
 * @event polymer-select
 * @param {Object} detail
 *   @param {boolean} detail.isSelected true for selection and false for deselection
 *   @param {Object} detail.item the item element
 */
-->


<polymer-element name="polymer-selection" attributes="multi" assetpath="../polymer-selection/">
  <template>
    <style>
      :host {
        display: none !important;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-selection', {
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      ready: function() {
        this.clear();
      },
      clear: function() {
        this.selection = [];
      },
      /**
       * Retrieves the selected item(s).
       * @method getSelection
       * @returns Returns the selected item(s). If the multi property is true,
       * getSelection will return an array, otherwise it will return 
       * the selected item or undefined if there is no selection.
      */
      getSelection: function() {
        return this.multi ? this.selection : this.selection[0];
      },
      /**
       * Indicates if a given item is selected.
       * @method isSelected
       * @param {any} item The item whose selection state should be checked.
       * @returns Returns true if `item` is selected.
      */
      isSelected: function(item) {
        return this.selection.indexOf(item) >= 0;
      },
      setItemSelected: function(item, isSelected) {
        if (item !== undefined && item !== null) {
          if (isSelected) {
            this.selection.push(item);
          } else {
            var i = this.selection.indexOf(item);
            if (i >= 0) {
              this.selection.splice(i, 1);
            }
          }
          this.fire("polymer-select", {isSelected: isSelected, item: item});
        }
      },
      /**
       * Set the selection state for a given `item`. If the multi property
       * is true, then the selected state of `item` will be toggled; otherwise
       * the `item` will be selected.
       * @method select
       * @param {any} item: The item to select.
      */
      select: function(item) {
        if (this.multi) {
          this.toggle(item);
        } else if (this.getSelection() !== item) {
          this.setItemSelected(this.getSelection(), false);
          this.setItemSelected(item, true);
        }
      },
      /**
       * Toggles the selection state for `item`.
       * @method toggle
       * @param {any} item: The item to toggle.
      */
      toggle: function(item) {
        this.setItemSelected(item, !this.isSelected(item));
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-selector is used to manage a list of elements that can be selected.
 * The attribute "selected" indicates which item element is being selected.
 * The attribute "multi" indicates if multiple items can be selected at once.
 * Tapping on the item element would fire "polymer-activate" event. Use
 * "polymer-select" event to listen for selection changes.
 *
 * Example:
 *
 *     <polymer-selector selected="0">
 *       <div>Item 1</div>
 *       <div>Item 2</div>
 *       <div>Item 3</div>
 *     </polymer-selector>
 *
 * polymer-selector is not styled.  So one needs to use "polymer-selected" CSS
 * class to style the selected element.
 * 
 *     <style>
 *       .item.polymer-selected {
 *         background: #eee;
 *       }
 *     </style>
 *     ...
 *     <polymer-selector>
 *       <div class="item">Item 1</div>
 *       <div class="item">Item 2</div>
 *       <div class="item">Item 3</div>
 *     </polymer-selector>
 *
 * @class polymer-selector
 */
/**
 * Fired when an item's selection state is changed. This event is fired both
 * when an item is selected or deselected. The `isSelected` detail property
 * contains the selection state.
 * 
 * @event polymer-select
 * @param {Object} detail
 *   @param {boolean} detail.isSelected true for selection and false for deselection
 *   @param {Object} detail.item the item element
 */
/**
 * Fired when an item element is tapped.
 * 
 * @event polymer-activate
 * @param {Object} detail
 *   @param {Object} detail.item the item element
 */
-->



<polymer-element name="polymer-selector" attributes="selected multi valueattr selectedClass selectedProperty selectedItem selectedModel selectedIndex notap target itemsSelector activateEvent" assetpath="../polymer-selector/">
  <template>
    <polymer-selection id="selection" multi="{{multi}}" on-polymer-select="{{selectionSelect}}"></polymer-selection>
    <content id="items" select="*"></content>
  </template>
  <script>
    Polymer('polymer-selector', {
      /**
       * Gets or sets the selected element.  Default to use the index
       * of the item element.
       *
       * If you want a specific attribute value of the element to be
       * used instead of index, set "valueattr" to that attribute name.
       *
       * Example:
       *
       *     <polymer-selector valueattr="label" selected="foo">
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </polymer-selector>
       *
       * In multi-selection this should be an array of values.
       *
       * Example:
       *
       *     <polymer-selector id="selector" valueattr="label" multi>
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </polymer-selector>
       *
       *     this.$.selector.selected = ['foo', 'zot'];
       *
       * @attribute selected
       * @type Object
       * @default null
       */
      selected: null,
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      /**
       * Specifies the attribute to be used for "selected" attribute.
       *
       * @attribute valueattr
       * @type string
       * @default 'name'
       */
      valueattr: 'name',
      /**
       * Specifies the CSS class to be used to add to the selected element.
       * 
       * @attribute selectedClass
       * @type string
       * @default 'polymer-selected'
       */
      selectedClass: 'polymer-selected',
      /**
       * Specifies the property to be used to set on the selected element
       * to indicate its active state.
       *
       * @attribute selectedProperty
       * @type string
       * @default 'active'
       */
      selectedProperty: 'active',
      /**
       * Returns the currently selected element. In multi-selection this returns
       * an array of selected elements.
       * 
       * @attribute selectedItem
       * @type Object
       * @default null
       */
      selectedItem: null,
      /**
       * In single selection, this returns the model associated with the
       * selected element.
       * 
       * @attribute selectedModel
       * @type Object
       * @default null
       */
      selectedModel: null,
      /**
       * In single selection, this returns the selected index.
       *
       * @attribute selectedIndex
       * @type number
       * @default -1
       */
      selectedIndex: -1,
      /**
       * The target element that contains items.  If this is not set 
       * polymer-selector is the container.
       * 
       * @attribute target
       * @type Object
       * @default null
       */
      target: null,
      /**
       * This can be used to query nodes from the target node to be used for 
       * selection items.  Note this only works if the 'target' property is set.
       *
       * Example:
       *
       *     <polymer-selector target="{{$.myForm}}" itemsSelector="input[type=radio]"></polymer-selector>
       *     <form id="myForm">
       *       <label><input type="radio" name="color" value="red"> Red</label> <br>
       *       <label><input type="radio" name="color" value="green"> Green</label> <br>
       *       <label><input type="radio" name="color" value="blue"> Blue</label> <br>
       *       <p>color = {{color}}</p>
       *     </form>
       * 
       * @attribute itemSelector
       * @type string
       * @default ''
       */
      itemsSelector: '',
      /**
       * The event that would be fired from the item element to indicate
       * it is being selected.
       *
       * @attribute activateEvent
       * @type string
       * @default 'tap'
       */
      activateEvent: 'tap',
      notap: false,
      ready: function() {
        this.activateListener = this.activateHandler.bind(this);
        this.observer = new MutationObserver(this.updateSelected.bind(this));
        if (!this.target) {
          this.target = this;
        }
      },
      get items() {
        var nodes = this.target !== this ? (this.itemsSelector ? 
            this.target.querySelectorAll(this.itemsSelector) : 
                this.target.children) : this.$.items.getDistributedNodes();
        return Array.prototype.filter.call(nodes || [], function(n) {
          return n && n.localName !== 'template';
        });
      },
      targetChanged: function(old) {
        if (old) {
          this.removeListener(old);
          this.observer.disconnect();
        }
        if (this.target) {
          this.addListener(this.target);
          this.observer.observe(this.target, {childList: true});
        }
      },
      addListener: function(node) {
        node.addEventListener(this.activateEvent, this.activateListener);
      },
      removeListener: function(node) {
        node.removeEventListener(this.activateEvent, this.activateListener);
      },
      get selection() {
        return this.$.selection.getSelection();
      },
      selectedChanged: function() {
        this.updateSelected();
      },
      updateSelected: function() {
        this.validateSelected();
        if (this.multi) {
          this.clearSelection();
          this.selected && this.selected.forEach(function(s) {
            this.valueToSelection(s);
          }, this);
        } else {
          this.valueToSelection(this.selected);
        }
      },
      validateSelected: function() {
        // convert to an array for multi-selection
        if (this.multi && !Array.isArray(this.selected) && 
            this.selected !== null && this.selected !== undefined) {
          this.selected = [this.selected];
        }
      },
      clearSelection: function() {
        if (this.multi) {
          this.selection.slice().forEach(function(s) {
            this.$.selection.setItemSelected(s, false);
          }, this);
        } else {
          this.$.selection.setItemSelected(this.selection, false);
        }
        this.selectedItem = null;
        this.$.selection.clear();
      },
      valueToSelection: function(value) {
        var item = (value === null || value === undefined) ? 
            null : this.items[this.valueToIndex(value)];
        this.$.selection.select(item);
      },
      updateSelectedItem: function() {
        this.selectedItem = this.selection;
      },
      selectedItemChanged: function() {
        if (this.selectedItem) {
          var t = this.selectedItem.templateInstance;
          this.selectedModel = t ? t.model : undefined;
        } else {
          this.selectedModel = null;
        }
        this.selectedIndex = this.selectedItem ? 
            parseInt(this.valueToIndex(this.selected)) : -1;
      },
      valueToIndex: function(value) {
        // find an item with value == value and return it's index
        for (var i=0, items=this.items, c; (c=items[i]); i++) {
          if (this.valueForNode(c) == value) {
            return i;
          }
        }
        // if no item found, the value itself is probably the index
        return value;
      },
      valueForNode: function(node) {
        return node[this.valueattr] || node.getAttribute(this.valueattr);
      },
      // events fired from <polymer-selection> object
      selectionSelect: function(e, detail) {
        this.updateSelectedItem();
        if (detail.item) {
          this.applySelection(detail.item, detail.isSelected);
        }
      },
      applySelection: function(item, isSelected) {
        if (this.selectedClass) {
          item.classList.toggle(this.selectedClass, isSelected);
        }
        if (this.selectedProperty) {
          item[this.selectedProperty] = isSelected;
        }
      },
      // event fired from host
      activateHandler: function(e) {
        if (!this.notap) {
          var i = this.findDistributedTarget(e.target, this.items);
          if (i >= 0) {
            var item = this.items[i];
            var s = this.valueForNode(item) || i;
            if (this.multi) {
              if (this.selected) {
                this.addRemoveSelected(s);
              } else {
                this.selected = [s];
              }
            } else {
              this.selected = s;
            }
            this.asyncFire('polymer-activate', {item: item});
          }
        }
      },
      addRemoveSelected: function(value) {
        var i = this.selected.indexOf(value);
        if (i >= 0) {
          this.selected.splice(i, 1);
        } else {
          this.selected.push(value);
        }
        this.valueToSelection(value);
      },
      findDistributedTarget: function(target, nodes) {
        // find first ancestor of target (including itself) that
        // is in nodes, if any
        while (target && target != this) {
          var i = Array.prototype.indexOf.call(nodes, target);
          if (i >= 0) {
            return i;
          }
          target = target.parentNode;
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->


<polymer-element name="polymer-ui-theme-aware" attributes="theme" assetpath="../polymer-ui-theme-aware/">
  <script>
    PolymerUI = {
      validateTheme: function() {
        var theme = this.theme;
        var defaultTheme = this.defaultTheme;
        if (!theme) {
          var p = this;
          while (p && !theme) {
            theme = p.getAttribute && p.getAttribute('theme');
            defaultTheme = defaultTheme || p.defaultTheme;
            p = p.parentNode || p.host;
          }
        }
        this.activeTheme = this.theme || theme || defaultTheme;
      }
    };
    Polymer('polymer-ui-theme-aware', {
      defaultTheme: '',
      activeTheme: '',
      validateTheme: PolymerUI.validateTheme,
      enteredView: function() {
        this.validateTheme();
      },
      themeChanged: function() {
        this.activeTheme = this.theme;
      },
      activeThemeChanged: function(old) {
        this.classList.switch(old, this.activeTheme);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-menu is a polymer-selector with theme propagation.  It styles to look like 
 * a menu and should be used in conjunction with polymer-ui-menu-item.
 *
 * Example:
 * 
 *     <polymer-ui-menu selected="0">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 * The "selectedItem" property returns the currently selected item.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0" selectedItem="{{item}}">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 *     <div>selected label: {{item.label}}</div>
 *
 * The event "polymer-select" can also be used to listen for selection change.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0" on-polymer-select="{{selectAction}}">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 *     ...
 *
 *     selectAction: function(e, detail) {
 *       if (detail.isSelected) {
 *         var selectedItem = detail.item;
 *         ...
 *       }
 *     }
 *
 * @class polymer-ui-menu
 * @extends polymer-selector
 */
-->




<polymer-element name="polymer-ui-menu" extends="polymer-selector" attributes="theme" on-polymer-select="{{selectionChange}}" assetpath="../polymer-ui-menu/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  /* technical */
  display: block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* size */
  padding: 0.4em;
  font-weight: bold;
}

:host(.polymer-ui-light-theme:host) {
  color: #333333;
}

:host(.polymer-ui-dark-theme:host) {
  background: -webkit-linear-gradient(-60deg, #3d3d3d, #353535);
  background: -moz-linear-gradient(-60deg, #3d3d3d, #353535);
  background: -ms-linear-gradient(-60deg, #3d3d3d, #353535);
  color: #ededed;
}
</style>
    <shadow></shadow>
  </template>
  <script>
    Polymer('polymer-ui-menu', {
      activeTheme: '',
      validateTheme: PolymerUI.validateTheme,
      enteredView: function() {
        this.validateTheme();
      },
      themeChanged: function() {
        this.activeTheme = this.theme;
      },
      activeThemeChanged: function(old) {
        this.classList.switch(old, this.activeTheme);
      },
      selectionChange: function(e, detail) {
        if (detail.isSelected) {
          var i = detail.item;
          // find nested selected item
          while (i.selectedItem) {
            i = i.selectedItem;
          }
          this.selectedItem = i;
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-meta is used to manage metadata.  When an instance of polymer-meta
 * is created, it's automatically registered and add to the metaData storage given an id
 * is set on the element. Use byId() to retrive a specific polymer-meta and
 * the property "list" to retrieve all registered polymer-meta's.
 *
 * @class polymer-meta
 */
-->


<polymer-element name="polymer-meta" attributes="list label type" assetpath="../polymer-meta/">
  <script>
    (function() {
      var SKIP_ID = 'meta';
      var metaData = {}, metaArray = {};

      Polymer('polymer-meta', {
        alwaysPrepare: true,
        type: 'default',
        ready: function() {
          this.idChanged();
        },
        get metaArray() {
          var t = this.type;
          if (!metaArray[t]) {
            metaArray[t] = [];
          }
          return metaArray[t];
        },
        get metaData() {
          var t = this.type;
          if (!metaData[t]) {
            metaData[t] = {};
          }
          return metaData[t];
        },
        idChanged: function(old) {
          if (this.id && this.id !== SKIP_ID) {
            this.unregister(this, old);
            this.metaData[this.id] = this;
            this.metaArray.push(this);
          }
        },
        unregister: function(meta, id) {
          delete this.metaData[id || meta.id];
          var i = this.metaArray.indexOf(meta);
          if (i >= 0) {
            this.metaArray.splice(i, 1);
          }
        },
        get list() {
          return this.metaArray;
        },
        get archetype() {
          return this.querySelector('template');
        },
        byId: function(id) {
          return this.metaData[id];
        },
        get childMetas() {
          return this.querySelectorAll(this.localName);
        }
      });
    })();
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
* Polymer UI Elements
*
* @module Polymer UI Elements
*/  
/**
 * polymer-ui-iconset allows users to define their own icon sets.
 *
 * Example:
 *
 *     <polymer-ui-iconset id="my-icons" src="my-icons.png" width="96" iconsize="24"
 *         icons="location place starta stopb bus car train walk">
 *     </polymer-ui-iconset>
 *
 * The above will automatically register the icon set "my-icons" to the iconset
 * database.  To use the user-defined icon set, prefix the icon with
 * the icon set e.g. "my-icons:clock"
 *
 * Example:
 *
 *     <polymer-ui-icon-button icon="my-icons:car"></polymer-ui-icon-button>
 *
 * @class polymer-ui-iconset
 */
-->


<polymer-element name="polymer-ui-iconset" extends="polymer-meta" attributes="src width icons iconsize" assetpath="../polymer-ui-iconset/">
  <script>
    Polymer('polymer-ui-iconset', {
      width: 0,
      icons: '',
      iconsize: 0,
      offsetx: 0,
      offsety: 0,
      type: 'iconset',
      ready: function() {
        // TODO(sorvell): ensure iconset's src is always relative to the main
        // document
        if (this.src && (this.ownerDocument !== document)) {
          this.src = this.resolvePath(this.src, this.ownerDocument.baseURI);
        }
        this.super();
        this.iconsChanged();
        this.updateThemes();
      },
      iconsChanged: function() {
        this.iconMap = {};
        var ox = this.offsetx;
        var oy = this.offsety;
        this.icons && this.icons.split(/\s+/g).forEach(function(name, i) {
          this.iconMap[name] = {
            offsetx: ox,
            offsety: oy
          }
          if (ox + this.iconsize < this.width) {
            ox += this.iconsize;
          } else {
            ox = this.offsetx;
            oy += this.iconsize;
          }
        }, this);
      },
      updateThemes: function() {
        this.themes = {};
        var ts = this.querySelectorAll('property[theme]');
        ts && ts.array().forEach(function(t) {
          this.themes[t.getAttribute('theme')] = {
            offsetx: parseInt(t.getAttribute('offsetx')) || 0,
            offsety: parseInt(t.getAttribute('offsety')) || 0
          };
        }, this);
      },
      // TODO(ffu): support retrived by index e.g. getOffset(10);
      getOffset: function(icon, theme) {
        var i = this.iconMap[icon];
        var t = this.themes[theme];
        if (i && t) {
          return {
            offsetx: i.offsetx + t.offsetx,
            offsety: i.offsety + t.offsety
          }
        }
        return i;
      }
    });
  </script>
</polymer-element>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<polymer-ui-iconset id="polymer-ui-icons" src="../polymer-ui-action-icons/action-icons.png" width="24" iconsize="24" icons="drawer menu search dropdown close add trash refresh settings dialoga 
           left right down up grid contact account plus time marker 
           briefcase array columns list modules quilt stream maximize shrink sort 
           shortcut dialog twitter facebook favorite gplus filter tag plusone dots">

  <property theme="polymer-ui-light-theme" offsetx="24"></property>
  <property theme="polymer-ui-dark-theme" offsetx="72"></property>
</polymer-ui-iconset>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
* Polymer UI Elements
*
* @module Polymer UI Elements
*/  
/**
 * polymer-ui-icon is a 24x24 glyph expressed as a background-image.
 *
 * Example:
 *
 *     <polymer-ui-icon src="star.png"></polymer-ui-icon>
 *
 * Optionally can use other size like 32x32 by setting the attribute "size" to "32":
 *
 *     <polymer-ui-icon src="big_star.png" size="32"></polymer-ui-icon>
 *
 * Polymer includes an icon set.  The property "icon" can be used
 * to specify which icon to use.
 *
 * Example:
 *
 *     <polymer-ui-icon icon="menu"></polymer-ui-icon>
 *
 * See <a href="polymer-ui-iconset.html">polymer-ui-iconset</a> on how to use
 * your own icon set.
 *
 * @class polymer-ui-icon
 */
-->





<polymer-element name="polymer-ui-icon" extends="polymer-ui-theme-aware" attributes="src size index icon" assetpath="../polymer-ui-icon/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  display: inline-block;
  vertical-align: middle;
  cursor: pointer;
  background-repeat: no-repeat;
}
</style>
    <polymer-ui-iconset id="meta"></polymer-ui-iconset>
    <content></content>
  </template>
  <script>
    Polymer('polymer-ui-icon', {
      /**
       * The URL of an image for the icon.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',
      /**
       * Specifies the size of the icon.
       *
       * @attribute size
       * @type string
       * @default 24
       */
      size: 24,
      /**
       * Specifies the icon from the icon set.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',
      defaultIconset: 'polymer-ui-icons',
      observe: {
        icon: 'updateIcon',
        activeTheme: 'updateIcon'
      },
      ready: function() {
        this.sizeChanged();
      },
      sizeChanged: function() {
        this.style.width = this.style.height = this.size + 'px';
      },
      srcChanged: function() {
        this.style.backgroundImage = 'url(' + this.src + ')';
        this.style.backgroundPosition = 'center';
        this.style.backgroundSize = this.size + 'px ' + this.size + 'px';
      },
      getIconset: function(name) {
        return this.$.meta.byId(name || this.defaultIconset);
      },
      updateIcon: function() {
        if (!this.icon) {
          return;
        }
        var a = this.icon.split(':');
        var icon = a.pop();
        var n = a.pop();
        var s = this.getIconset(n);
        if (s) {
          var o = s.getOffset(icon, this.activeTheme);
          if (o) {
            var r = this.size / s.iconsize;
            this.style.backgroundImage = 'url(' + s.src + ')';
            this.style.backgroundPosition = 
                (-o.offsetx * r + 'px') + ' ' + (-o.offsety * r + 'px');
            this.style.backgroundSize = r === 1 ? 'auto' : s.width * r + 'px';
          }
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-menu-item is styled to look like a menu item.  It should be used
 * in conjunction with polymer-ui-menu or polymer-ui-sibebar-menu.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *
 * @class polymer-ui-menu-item
 */
/**
 * The URL of an image for the icon.
 *
 * @attribute src
 * @type string
 * @default ''
 */
/**
 * Specifies the icon from the Polymer icon set.
 *
 * @attribute icon
 * @type string
 * @default ''
 */
/**
 * Specifies the label for the menu item.
 *
 * @attribute label
 * @type string
 * @default ''
 */
/**
 * Specifies the URL of the link it goes to when tapped on.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="favorite" label="Favorite" href="http://www.polymer-project.org/"></polymer-ui-menu-item>
 *
 * If you want more control on the link, e.g. specify the target for where to
 * open the linked document, you can put &lt;a> directly inside the menu-item.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="favorite" label="Favorite">
 *       <a href="http://www.polymer-project.org/" target="_self"></a>
 *     </polymer-ui-menu-item>
 *
 * @attribute href
 * @type string
 * @default ''
 */
-->




<polymer-element name="polymer-ui-menu-item" extends="polymer-ui-theme-aware" attributes="src label icon item href" assetpath="../polymer-ui-menu-item/">
  <template>
    <style>/*
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host { 
  display: block;
  position: relative;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  height: 40px;
  line-height: 35px;
  font-size: 16px;
  padding: 0 10px;
  border: 1px solid transparent;
  border-radius: 3px;
  white-space: nowrap;
  cursor: pointer;
  opacity: 0.5;
}

:host(:hover:host) {
  opacity: 0.9;
}

:host(.polymer-selected:host, [active]:host) {
  opacity: 1;
}

:host(.polymer-ui-light-theme.polymer-selected:host, .polymer-ui-light-theme[active]:host) {
  background: #f2f2f2;
  border: 1px solid rgba(0, 0, 0, 0.15);
}

:host(.polymer-ui-dark-theme:host) {
  color: #b3b3b3;
}
	
:host(.polymer-ui-dark-theme:hover:host) {
  color: rgba(255, 255, 255, 0.9);
}

:host(.polymer-ui-dark-theme.polymer-selected:host, .polymer-ui-dark-theme[active]:host) {
  background-color: #000;
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.9);
}

:host([active].no-active-bg:host) {
  background-color: transparent;
  border: 1px solid transparent;
}

/* icon and label */
polymer-ui-icon:not([showing]) {
  display: none !important;
}

polymer-ui-icon {
  margin-right: 16px;
}

#label {
  vertical-align: middle;
  padding-right: 20px;
}

/*@polyfill :host #label > a, #link */
::content > a, #link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: -1px;
}

#link[hidden] {
  display: none;
}
</style>
    <polymer-ui-icon src="{{src}}" icon="{{icon}}" showing?="{{icon || src}}"></polymer-ui-icon>
    <span id="label">{{label}}<content></content></span>
    <a id="link" href="{{href}}" hidden?="{{!href}}"></a>
  </template>
  <script>
    Polymer('polymer-ui-menu-item', {
      label: '',
      // calc item's offset middle pos instead of using offsetTop/Height 
      // directly which requires to wait for submenu's collapsing transition to 
      // complete first before it can return the correct pos.
      getOffsetMiddle: function() {
        var p = this.parentNode;
        if (p) {
          var i = Array.prototype.indexOf.call(p.items, this);
          var h = this.getItemHeight();
          return i * h + h/2 + p.items[0].offsetTop;
        }
      },
      getItemHeight: function() {
        return this.offsetHeight;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-collapse is used to add collapsible behavior to the
 * target element.  It adjusts the height or width of the target element
 * to make the element collapse and expand.
 *
 * Example:
 *
 *     <button on-click="{{toggle}}">toggle collapse</button>
 *     <div id="demo">
 *       ...
 *     </div>
 *     <polymer-collapse id="collapse" targetId="demo"></polymer-collapse>
 *
 *     ...
 *
 *     toggle: function() {
 *       this.$.collapse.toggle();
 *     }
 *
 * @class polymer-collapse
 */
-->


<polymer-element name="polymer-collapse" attributes="targetId target horizontal closed duration fixedSize size" assetpath="../polymer-collapse/">
  <template>
    <style polymer-scope="controller">/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.polymer-collapse-closed {
  display: none;
}</style>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.polymer-collapse-closed {
  display: none;
}</style>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-collapse', {
      /**
       * The id of the target element.
       *
       * @attribute targetId
       * @type string
       * @default ''
       */
      targetId: '',
      /**
       * The target element.
       *
       * @attribute target
       * @type object
       * @default null
       */
      target: null,
      /**
       * If true, the orientation is horizontal; otherwise is vertical.
       *
       * @attribute horizontal
       * @type boolean
       * @default false
       */
      horizontal: false,
      /**
       * If true, the target element is hidden/collapsed.
       *
       * @attribute closed
       * @type boolean
       * @default false
       */
      closed: false,
      /**
       * Collapsing/expanding animation duration in second.
       *
       * @attribute duration
       * @type number
       * @default 0.33
       */
      duration: 0.33,
      /**
       * If true, the size of the target element is fixed and is set
       * on the element.  Otherwise it will try to 
       * use auto to determine the natural size to use
       * for collapsing/expanding.
       *
       * @attribute fixedSize
       * @type boolean
       * @default false
       */
      fixedSize: false,
      size: null,
      attached: function() {
        this.installControllerStyles();
        this.inDocument = true;
        this.async(function() {
          this.afterInitialUpdate = true;
        });
      },
      detached: function() {
        if (this.target) {
          this.removeListeners(this.target);
        }
      },
      targetIdChanged: function() {
        var p = this.parentNode;
        while (p.parentNode) {
          p = p.parentNode;
        }
        this.target = p.querySelector('#' + this.targetId);
      },
      targetChanged: function(old) {
        if (old) {
          this.removeListeners(old);
        }
        this.horizontalChanged();
        this.isTargetReady = !!this.target;
        if (this.target) {
          this.target.style.overflow = 'hidden';
          this.addListeners(this.target);
          // set polymer-collapse-closed class initially to hide the target
          this.toggleClosedClass(true);
        }
        // don't need to update if the size is already set and it's opened
        if (!this.fixedSize || !this.closed) {
          this.update();
        }
      },
      addListeners: function(node) {
        this.transitionEndListener = this.transitionEndListener || 
            this.transitionEnd.bind(this);
        node.addEventListener('webkitTransitionEnd', this.transitionEndListener);
        node.addEventListener('transitionend', this.transitionEndListener);
      },
      removeListeners: function(node) {
        node.removeEventListener('webkitTransitionEnd', this.transitionEndListener);
        node.removeEventListener('transitionend', this.transitionEndListener);
      },
      horizontalChanged: function() {
        this.dimension = this.horizontal ? 'width' : 'height';
      },
      closedChanged: function() {
        this.update();
      },
      /** 
       * Toggle the closed state of the collapsible.
       *
       * @method toggle
       */
      toggle: function() {
        this.closed = !this.closed;
      },
      setTransitionDuration: function(duration) {
        var s = this.target.style;
        s.webkitTransition = s.transition = duration ? 
            (this.dimension + ' ' + duration + 's') : null;
        if (duration === 0) {
          this.async('transitionEnd');
        }
      },
      transitionEnd: function() {
        if (!this.closed && !this.fixedSize) {
          this.updateSize('auto', null);
        }
        this.setTransitionDuration(null);
        this.toggleClosedClass(this.closed);
      },
      toggleClosedClass: function(add) {
        this.hasClosedClass = add;
        this.target.classList.toggle('polymer-collapse-closed', add);
      },
      updateSize: function(size, duration, forceEnd) {
        if (duration) {
          this.calcSize();
        }
        this.setTransitionDuration(duration);
        var s = this.target.style;
        var nochange = s[this.dimension] === size;
        s[this.dimension] = size;
        // transitonEnd will not be called if the size has not changed
        if (forceEnd && nochange) {
          this.transitionEnd();
        }
      },
      update: function() {
        if (!this.target || !this.inDocument) {
          return;
        }
        if (!this.isTargetReady) {
          this.targetChanged(); 
        }
        this.horizontalChanged();
        this[this.closed ? 'hide' : 'show']();
      },
      calcSize: function() {
        return this.target.getBoundingClientRect()[this.dimension] + 'px';
      },
      getComputedSize: function() {
        return getComputedStyle(this.target)[this.dimension];
      },
      show: function() {
        this.toggleClosedClass(false);
        // for initial update, skip the expanding animation to optimize
        // performance e.g. skip calcSize
        if (!this.afterInitialUpdate) {
          this.transitionEnd();
          return;
        }
        if (!this.fixedSize) {
          this.updateSize('auto', null);
          var s = this.calcSize();
          this.updateSize(0, null);
        }
        this.async(function() {
          this.updateSize(this.size || s, this.duration, true);
        });
      },
      hide: function() {
        // don't need to do anything if it's already hidden
        if (this.hasClosedClass && !this.fixedSize) {
          return;
        }
        if (this.fixedSize) {
          // save the size before hiding it
          this.size = this.getComputedSize();
        } else {
          this.updateSize(this.calcSize(), null);
        }
        this.async(function() {
          this.updateSize(0, this.duration);
        });
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-submenu-item is a menu-item that can contains other menu-items.
 * It should be used in conjunction with polymer-ui-menu or 
 * polymer-ui-sibebar-menu.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0">
 *       <polymer-ui-submenu-item icon="settings" label="Topics">
 *         <polymer-ui-menu-item label="Topics 1"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Topics 2"></polymer-ui-menu-item>
 *       </polymer-ui-submenu-item>
 *       <polymer-ui-submenu-item icon="settings" label="Favorites">
 *         <polymer-ui-menu-item label="Favorites 1"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Favorites 2"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Favorites 3"></polymer-ui-menu-item>
 *       </polymer-ui-submenu-item>
 *     </polymer-ui-menu>
 *
 * @class polymer-ui-submenu-item
 * @extends polymer-ui-menu-item
 */
-->






<polymer-element name="polymer-ui-submenu-item" extends="polymer-ui-menu-item" attributes="active selected selectedItem" assetpath="../polymer-ui-submenu-item/">
  <template>
    <style>/*
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host { 
  display: block;
}

/* menu */
#menu {
  margin-left: 44px;
  height: 0;
  /* override :host style on polymer-ui-menu */
  background-image: none !important;
  padding: 0 !important;
}
</style>
    <polymer-ui-menu-item id="item" src="{{src}}" label="{{label}}" icon="{{icon}}" active?="{{active}}" on-tap="{{activate}}">
      <content select=".item-content"></content>
    </polymer-ui-menu-item>
    <polymer-ui-menu id="menu" selected="{{selected}}" selecteditem="{{selectedItem}}">
      <content></content>
    </polymer-ui-menu>
    <polymer-collapse targetid="menu" closed="{{collapsed}}"></polymer-collapse>
  </template>
  <script>
    Polymer('polymer-ui-submenu-item', {
      active: false,
      collapsed: true,
      get items() {
        return this.$.menu.items;
      },
      hasItems: function() {
        return !!this.items.length;
      },
      unselectAllItems: function() {
        this.$.menu.selected = null;
        this.$.menu.clearSelection();
      },
      activeChanged: function() {
        if (this.hasItems()) {
          this.collapsed = !this.active;
        }
        if (!this.active) {
          this.unselectAllItems();
        }
        this.$.item.classList.toggle('no-active-bg', this.hasItems());
      },
      activate: function() {
        if (this.hasItems() && this.active) {
          this.collapsed = !this.collapsed;
          this.unselectAllItems();
          this.fire("polymer-select", {isSelected: true, item: this});
        }
      },
      getItemHeight: function() {
        return this.$ && this.$.item && this.$.item.offsetHeight;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-media-query can be used to data bind to a CSS media query.
 * The "query" property is a bare CSS media query.
 * The "queryMatches" property will be a boolean representing if the page matches that media query.
 *
 * polymer-media-query uses media query listeners to dynamically update the "queryMatches" property.
 * A "polymer-mediachange" event also fires when queryMatches changes.
 *
 * Example:
 *
 *      <polymer-media-query query="max-width: 640px" queryMatches="{{phoneScreen}}"></polymer-media-query>
 *
 * @class polymer-media-query
 */
-->


<polymer-element name="polymer-media-query" attributes="query queryMatches" assetpath="../polymer-media-query/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>

    Polymer('polymer-media-query', {
      /**
       * The Boolean return value of the media query
       * @attribute queryMatches
       * @type Boolean
       * @default false
       */
      queryMatches: false,
      /**
       * The CSS media query to evaulate
       * @attribute query
       * @type string
       * @default ''
       */
      query: '',
      ready: function() {
        this._mqHandler = this.queryHandler.bind(this);
        this._mq = null;
      },
      queryChanged: function() {
        if (this._mq) {
          this._mq.removeListener(this._mqHandler);
        }
        var query = this.query;
        if (query[0] !== '(') {
          query = '(' + this.query + ')';
        }
        this._mq = window.matchMedia(query);
        this._mq.addListener(this._mqHandler);
        this.queryHandler(this._mq);
      },
      queryHandler: function(mq) {
        this.queryMatches = mq.matches;
        this.asyncFire('polymer-mediachange', mq);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-toolbar is a horizontal bar containing elements that can perform actions.
 *
 * Example:
 *
 *     <polymer-ui-toolbar>
 *       <polymer-ui-icon-button src="menu.png" on-click="{{menuAction}}"></polymer-ui-icon-button>
 *       <div flex>Title</div>
 *       <polymer-ui-icon-button src="more.png" on-click="{{moreAction}}"></polymer-ui-icon-button>
 *     </polymer-ui-toolbar>
 *
 * polymer-ui-toolbar can adopt to smaller screen size.  If the attribute "responsive" is set
 * and the screen size is less than the responsiveWidth (default to 800px), the toolbar will
 * be moved to the bottom of the page.
 *
 * Example:
 *
 *     <polymer-ui-toolbar>
 *       <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
 *       <div flex>Title</div>
 *       <polymer-ui-toolbar responsive>
 *         <polymer-ui-icon-button icon="add"></polymer-ui-icon-button>
 *         <polymer-ui-icon-button icon="trash"></polymer-ui-icon-button>
 *         <polymer-ui-icon-button icon="search"></polymer-ui-icon-button>
 *       </polymer-ui-toolbar>
 *     </polymer-ui-toolbar>
 *
 * @class polymer-ui-toolbar
 */
-->





<polymer-element name="polymer-ui-toolbar" extends="polymer-ui-theme-aware" attributes="responsiveWidth" assetpath="../polymer-ui-toolbar/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  /* technical */
  display: block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* border/shadow */
	border-bottom: 1px solid rgba(0, 0, 0, 0.15);
	/* size */
  height: 60px;
  font-size: 21px;
	font-family: 'Helvetica Neue Medium', 'HelveticaNeue-Medium', Helvetica, sans-serif;
	position: relative;
}

:host(.polymer-ui-light-theme:host) {
  background: #f2f2f2 -webkit-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  background: #f2f2f2 -moz-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  background: #f2f2f2 -ms-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  color: #333333;
}

:host(.polymer-ui-dark-theme:host) {
  background: #444444 none;
  color: #f3f3f3;
}
  
:host(.narrow-layout[responsive]:host) {
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1;
  border: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.28);
}

/* TODO(sorvell): use of !important due to inability to 
  naturally win over an :host style */
/*@polyfill :host > polymer-ui-icon-button */
::content > polymer-ui-icon-button {
  margin: 0px 8px 0 8px !important;
}

/*@polyfill :host > polymer-ui-menu-button */
::content > polymer-ui-menu-button {
  margin: 0px 8px 0 8px !important;
}

/*@polyfill :host > polymer-ui-toolbar */
::content > polymer-ui-toolbar {
  margin: 0;
}

/*@polyfill :host > polymer-ui-toolbar:not(.narrow-layout) */
::content > polymer-ui-toolbar:not(.narrow-layout) {
  border: 0;
  background: transparent none;
}
</style>
    <polymer-flex-layout align="center"></polymer-flex-layout>
    <polymer-media-query query="max-width: {{responsiveWidth}}" querymatches="{{queryMatches}}"></polymer-media-query>
    <content></content>
  </template>
  <script>
    Polymer('polymer-ui-toolbar', {
      responsiveWidth: '800px',
      queryMatches: false,
      defaultTheme: 'polymer-ui-light-theme',
      queryMatchesChanged: function() {
        this.classList.toggle('narrow-layout', this.queryMatches);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-icon-button enables you to place an image centered in a button.
 *
 * Example:
 *
 *     <polymer-ui-icon-button src="star.png"></polymer-ui-icon-button>
 *
 * Polymer includes an icon set.  The property "icon" can be used
 * to specify which icon to use.
 *
 * Example:
 *
 *     <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
 *
 * @class polymer-ui-icon-button
 */
-->



<polymer-element name="polymer-ui-icon-button" extends="polymer-ui-theme-aware" attributes="src index icon active" assetpath="../polymer-ui-icon-button/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
:host {
  display: inline-block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  width: 38px;
  height: 38px;
  background-image: none;
  border-radius: 2px;
  padding: 7px;
  margin: 2px;
  vertical-align: middle;
  cursor: pointer;
}
  
:host(.outline:host) {
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(:hover:host) {
  box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(.selected:host) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.05), 0 0 0 1px rgba(0, 0, 0, 0.12);
}

:host(:active:host, .selected:active:host) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.12);
}
  
:host(.polymer-ui-dark-theme.outline:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.polymer-ui-dark-theme:hover:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 1px 0 0 rgba(200, 200, 200, 0.12), 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.polymer-ui-dark-theme.selected:host) {
  background-color: rgba(220, 220, 220, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.05), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

:host(.polymer-ui-dark-theme:active:host, .polymer-ui-dark-theme.selected:active:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.1), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

polymer-ui-icon {
  display: block !important;
}</style>
    <polymer-ui-icon src="{{src}}" index="{{index}}" icon="{{icon}}"><content></content></polymer-ui-icon>
  </template>
  <script>
    Polymer('polymer-ui-icon-button', {
      /**
       * The URL of an image for the icon.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',
      /**
       * If true, border is placed around the button to indicate
       * active state.
       *
       * @attribute active
       * @type boolean
       * @default false
       */
      active: false,
      /**
       * Specifies the icon from the Polymer icon set.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',
      /**
       * If a theme is applied that includes an icon set, the index of the 
       * icon to display.
       *
       * @attribute index
       * @type number
       * @default -1
       */     
      index: -1,
      activeChanged: function() {
        // TODO(sjmiles): sugar this common case
        this.classList.toggle('selected', this.active);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-xhr can be used to perform XMLHttpRequests.
 
 * Example:
 *
 *     <polymer-xhr id="xhr"></polymer-xhr>
 *     ...
 *     this.$.xhr.request({url: url, params: params, callback: callback});
 *
 * @class polymer-xhr
 */
-->


<polymer-element name="polymer-xhr" assetpath="../polymer-ajax/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-xhr', {
      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },
      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      },
      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },
      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously.
       *        To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        var params = this.toQueryString(options.params);
        if (params && method == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(method == 'POST' ? (options.body || params) : null);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-ajax can be used to perform XMLHttpRequests.
 *
 * Note: The params attribute must be double quoted JSON
 * 
 * Example:
 *
 *     <polymer-ajax auto url="http://gdata.youtube.com/feeds/api/videos/" 
 *         params='{"alt":"json", "q":"chrome"}'
 *         handleAs="json"
 *         on-polymer-response="{{handleResponse}}">
 *     </polymer-ajax>
 *
 * @class polymer-ajax
 */
/**
 * Fired when a response is received.
 * 
 * @event polymer-response
 */
/**
 * Fired when an error is received.
 * 
 * @event polymer-error
 */
/**
 * Fired whenever a response or an error is received.
 *
 * @event polymer-complete
 */
-->



<polymer-element name="polymer-ajax" attributes="url handleAs auto params response method headers body contentType" assetpath="../polymer-ajax/">
  <script>
    Polymer('polymer-ajax', {
      /**
       * The URL target of the request.
       * 
       * @attribute url
       * @type string
       * @default ''
       */
      url: '',
      /**
       * Specifies what data to store in the 'response' property, and
       * to deliver as 'event.response' in 'response' events.
       * 
       * One of:
       * 
       *    `text`: uses XHR.responseText
       *    
       *    `xml`: uses XHR.responseXML
       *    
       *    `json`: uses XHR.responseText parsed as JSON
       *  
       * @attribute handleAs
       * @type string
       * @default 'text'
       */
      handleAs: '',
      /**
       * If true, automatically performs an Ajax request when either url or params has changed.
       *
       * @attribute auto
       * @type boolean
       * @default false
       */
      auto: false,
      /**
       * Parameters to send to the specified URL, as JSON.
       *  
       * @attribute params
       * @type string (JSON)
       * @default ''
       */
      params: '',
      /**
       * Returns the response object.
       *
       * @attribute response
       * @type Object
       * @default null
       */
      response: null,
      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', 'DELETE'.
       * Default is 'GET'.
       *
       * @attribute method
       * @type string
       * @default ''
       */
      method: '',
      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <polymer-ajax auto url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handleAs="json"
       *         on-polymer-response="{{handleResponse}}">
       *     </polymer-ajax>
       *  
       * @attribute headers
       * @type Object
       * @default null
       */
      headers: null,
      /**
       * Optional raw body content to send when method === "POST"
       *
       * Example:
       *
       *     <polymer-ajax method="POST" auto url="http://somesite.com"
       *         body='{"foo":1, "bar":2}'>
       *     </polymer-ajax>
       *  
       * @attribute body
       * @type Object
       * @default null
       */
      body: null,
      /**
       * Content type to use when sending data.
       *
       * @attribute contentType
       * @type string
       * @default 'application/x-www-form-urlencoded'
       */
      contentType: 'application/x-www-form-urlencoded',
      ready: function() {
        this.xhr = document.createElement('polymer-xhr');
      },
      receive: function(response, xhr) {
        if (this.isSuccess(xhr)) {
          this.processResponse(xhr);
        } else {
          this.error(xhr);
        }
        this.complete(xhr);
      },
      isSuccess: function(xhr) {
        var status = xhr.status || 0;
        return !status || (status >= 200 && status < 300);
      },
      processResponse: function(xhr) {
        var response = this.evalResponse(xhr);
        this.response = response;
        this.fire('polymer-response', {response: response, xhr: xhr});
      },
      error: function(xhr) {
        var response = xhr.status + ': ' + xhr.responseText;
        this.fire('polymer-error', {response: response, xhr: xhr});
      },
      complete: function(xhr) {
        this.fire('polymer-complete', {response: xhr.status, xhr: xhr});
      },
      evalResponse: function(xhr) {
        return this[(this.handleAs || 'text') + 'Handler'](xhr);
      },
      xmlHandler: function(xhr) {
        return xhr.responseXML;
      },
      textHandler: function(xhr) {
        return xhr.responseText;
      },
      jsonHandler: function(xhr) {
        var r = xhr.responseText;
        try {
          return JSON.parse(r);
        } catch (x) {
          return r;
        }
      },
      urlChanged: function() {
        if (!this.handleAs) {
          var ext = String(this.url).split('.').pop();
          switch (ext) {
            case 'json':
              this.handleAs = 'json';
              break;
          }
        }
        this.autoGo();
      },
      paramsChanged: function() {
        this.autoGo();
      },
      autoChanged: function() {
        this.autoGo();
      },
      // TODO(sorvell): multiple side-effects could call autoGo 
      // during one micro-task, use a job to have only one action 
      // occur
      autoGo: function() {
        if (this.auto) {
          this.goJob = this.job(this.goJob, this.go, 0);
        }
      },
      /**
       * Performs an Ajax request to the url specified.
       *
       * @method go
       */
      go: function() {
        var args = this.xhrArgs || {};
        // TODO(sjmiles): alternatively, we could force POST if body is set
        if (this.method === 'POST') {
          args.body = this.body || args.body;
        }
        args.params = this.params || args.params;
        if (args.params && typeof(args.params) == 'string') {
          args.params = JSON.parse(args.params);
        }
        args.headers = this.headers || args.headers || {};
        if (args.headers && typeof(args.headers) == 'string') {
          args.headers = JSON.parse(args.headers);
        }
        if (this.contentType) {
          args.headers['content-type'] = this.contentType;
        }
        args.callback = this.receive.bind(this);
        args.url = this.url;
        args.method = this.method;
        return args.url && this.xhr.request(args);
      }
    });
  </script>
</polymer-element>



<polymer-element name="context-free-parser" attributes="url data" assetpath="../polymer-doc-viewer/">

  <template>

    <polymer-ajax url="{{url}}" response="{{text}}" auto=""></polymer-ajax>

  </template>

  <script id="test">

    Polymer('context-free-parser', {

      text: null,

      textChanged: function() {

        if (!this.text) {
          console.log('textChanged:', this.text);
          return;
        }

        var text = this.text;

        var top = {};
        var classes = [];
        var current = top;
        var subCurrent = {};

        function makePragma(object, pragma, content) {
          var p$ = object;
          var p = p$[pragma];
          if (!p) {
            p$[pragma] = p = [];
          }
          p.push(content);
        }

        var js_matches = text.match(/\/\*\*([\s\S]*?)\*\//g) || [];
        text = text.replace(/\/\*\*([\s\S]*?)\*\//g, '');
        var html_matches = text.match(/<!--([\s\S]*?)-->/g) || [];
        var matches = html_matches.concat(js_matches);

        matches.forEach(function(m) {

          var lines = m.replace(/\r\n/g, '\n').replace(/^\s*\/\*\*|^\s*\*\/|^\s*\*|^\s*\<\!-\-|^s*\-\-\>/gm, '').split('\n');
          
          var pragmas = [];
          lines = lines.filter(function(l) {
            var m = l.match(/\s*@(\w*) (.*)/);
            if (!m) {
              return true;
            }
            pragmas.push(m);
          });

          var code = lines.join('\n');
          
          pragmas.forEach(function(m) {
            var pragma = m[1], content = m[2];
            switch (pragma) {

              case 'class':
                current = {
                  name: content,
                  description: code
                };
                classes.push(current);
                break;
              
              case 'attribute':
              case 'method':
              case 'event':
                subCurrent = {
                  name: content,
                  description: code
                };
                makePragma(current, pragma + 's', subCurrent);
                break;

              case 'default':
              case 'type':
                subCurrent[pragma] = content;
                //makePragma(subCurrent, pragma, content);
                break;

              default:
                makePragma(current, pragma, content);
                break;
            }
          });
        });

        this.data = { classes : classes };
      },

      dataChanged: function() {
        this.fire('data-ready');
      }

    });

  </script>

</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<script>(function(){function t(t){this.tokens=[],this.tokens.links={},this.options=t||o.defaults,this.rules=h.normal,this.options.gfm&&(this.rules=this.options.tables?h.tables:h.gfm)}function e(t,e){if(this.options=e||o.defaults,this.links=t,this.rules=a.normal,!this.links)throw Error("Tokens array requires a `links` property.");this.options.gfm?this.rules=this.options.breaks?a.breaks:a.gfm:this.options.pedantic&&(this.rules=a.pedantic)}function s(t){this.tokens=[],this.token=null,this.options=t||o.defaults}function n(t,e){return t.replace(e?/&/g:/&(?!#?\w+;)/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function i(t,e){return t=t.source,e=e||"",function s(n,i){return n?(i=i.source||i,i=i.replace(/(^|[^\[])\^/g,"$1"),t=t.replace(n,i),s):RegExp(t,e)}}function r(){}function l(t){for(var e,s,n=1;arguments.length>n;n++){e=arguments[n];for(s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t}function o(e,i,r){if(r||"function"==typeof i){r||(r=i,i=null),i&&(i=l({},o.defaults,i));var h=t.lex(h,i),a=i.highlight,u=0,p=h.length,g=0;if(!a||3>a.length)return r(null,s.parse(h,i));for(var c=function(){delete i.highlight;var t=s.parse(h,i);return i.highlight=a,r(null,t)};p>g;g++)(function(t){return"code"===t.type?(u++,a(t.text,t.lang,function(e,s){return null==s||s===t.text?--u||c():(t.text=s,t.escaped=!0,--u||c(),void 0)})):void 0})(h[g])}else try{return i&&(i=l({},o.defaults,i)),s.parse(t.lex(e,i),i)}catch(f){if(f.message+="\nPlease report this to https://github.com/chjj/marked.",(i||o.defaults).silent)return"<p>An error occured:</p><pre>"+n(f.message+"",!0)+"</pre>";throw f}}var h={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:r,hr:/^( *[-*_]){3,} *(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,nptable:r,lheading:/^([^\n]+)\n *(=|-){3,} *\n*/,blockquote:/^( *>[^\n]+(\n[^\n]+)*\n*)+/,list:/^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:/^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,table:r,paragraph:/^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,text:/^[^\n]+/};h.bullet=/(?:[*+-]|\d+\.)/,h.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/,h.item=i(h.item,"gm")(/bull/g,h.bullet)(),h.list=i(h.list)(/bull/g,h.bullet)("hr",/\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)(),h._tag="(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b",h.html=i(h.html)("comment",/<!--[\s\S]*?-->/)("closed",/<(tag)[\s\S]+?<\/\1>/)("closing",/<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g,h._tag)(),h.paragraph=i(h.paragraph)("hr",h.hr)("heading",h.heading)("lheading",h.lheading)("blockquote",h.blockquote)("tag","<"+h._tag)("def",h.def)(),h.normal=l({},h),h.gfm=l({},h.normal,{fences:/^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,paragraph:/^/}),h.gfm.paragraph=i(h.paragraph)("(?!","(?!"+h.gfm.fences.source.replace("\\1","\\2")+"|")(),h.tables=l({},h.gfm,{nptable:/^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,table:/^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/}),t.rules=h,t.lex=function(e,s){var n=new t(s);return n.lex(e)},t.prototype.lex=function(t){return t=t.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n"),this.token(t,!0)},t.prototype.token=function(t,e){for(var s,n,i,r,l,o,a,u,p,t=t.replace(/^ +$/gm,"");t;)if((i=this.rules.newline.exec(t))&&(t=t.substring(i[0].length),i[0].length>1&&this.tokens.push({type:"space"})),i=this.rules.code.exec(t))t=t.substring(i[0].length),i=i[0].replace(/^ {4}/gm,""),this.tokens.push({type:"code",text:this.options.pedantic?i:i.replace(/\n+$/,"")});else if(i=this.rules.fences.exec(t))t=t.substring(i[0].length),this.tokens.push({type:"code",lang:i[2],text:i[3]});else if(i=this.rules.heading.exec(t))t=t.substring(i[0].length),this.tokens.push({type:"heading",depth:i[1].length,text:i[2]});else if(e&&(i=this.rules.nptable.exec(t))){for(t=t.substring(i[0].length),o={type:"table",header:i[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:i[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:i[3].replace(/\n$/,"").split("\n")},u=0;o.align.length>u;u++)o.align[u]=/^ *-+: *$/.test(o.align[u])?"right":/^ *:-+: *$/.test(o.align[u])?"center":/^ *:-+ *$/.test(o.align[u])?"left":null;for(u=0;o.cells.length>u;u++)o.cells[u]=o.cells[u].split(/ *\| */);this.tokens.push(o)}else if(i=this.rules.lheading.exec(t))t=t.substring(i[0].length),this.tokens.push({type:"heading",depth:"="===i[2]?1:2,text:i[1]});else if(i=this.rules.hr.exec(t))t=t.substring(i[0].length),this.tokens.push({type:"hr"});else if(i=this.rules.blockquote.exec(t))t=t.substring(i[0].length),this.tokens.push({type:"blockquote_start"}),i=i[0].replace(/^ *> ?/gm,""),this.token(i,e),this.tokens.push({type:"blockquote_end"});else if(i=this.rules.list.exec(t)){for(t=t.substring(i[0].length),r=i[2],this.tokens.push({type:"list_start",ordered:r.length>1}),i=i[0].match(this.rules.item),s=!1,p=i.length,u=0;p>u;u++)o=i[u],a=o.length,o=o.replace(/^ *([*+-]|\d+\.) +/,""),~o.indexOf("\n ")&&(a-=o.length,o=this.options.pedantic?o.replace(/^ {1,4}/gm,""):o.replace(RegExp("^ {1,"+a+"}","gm"),"")),this.options.smartLists&&u!==p-1&&(l=h.bullet.exec(i[u+1])[0],r===l||r.length>1&&l.length>1||(t=i.slice(u+1).join("\n")+t,u=p-1)),n=s||/\n\n(?!\s*$)/.test(o),u!==p-1&&(s="\n"===o[o.length-1],n||(n=s)),this.tokens.push({type:n?"loose_item_start":"list_item_start"}),this.token(o,!1),this.tokens.push({type:"list_item_end"});this.tokens.push({type:"list_end"})}else if(i=this.rules.html.exec(t))t=t.substring(i[0].length),this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:"pre"===i[1]||"script"===i[1],text:i[0]});else if(e&&(i=this.rules.def.exec(t)))t=t.substring(i[0].length),this.tokens.links[i[1].toLowerCase()]={href:i[2],title:i[3]};else if(e&&(i=this.rules.table.exec(t))){for(t=t.substring(i[0].length),o={type:"table",header:i[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:i[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:i[3].replace(/(?: *\| *)?\n$/,"").split("\n")},u=0;o.align.length>u;u++)o.align[u]=/^ *-+: *$/.test(o.align[u])?"right":/^ *:-+: *$/.test(o.align[u])?"center":/^ *:-+ *$/.test(o.align[u])?"left":null;for(u=0;o.cells.length>u;u++)o.cells[u]=o.cells[u].replace(/^ *\| *| *\| *$/g,"").split(/ *\| */);this.tokens.push(o)}else if(e&&(i=this.rules.paragraph.exec(t)))t=t.substring(i[0].length),this.tokens.push({type:"paragraph",text:"\n"===i[1][i[1].length-1]?i[1].slice(0,-1):i[1]});else if(i=this.rules.text.exec(t))t=t.substring(i[0].length),this.tokens.push({type:"text",text:i[0]});else if(t)throw Error("Infinite loop on byte: "+t.charCodeAt(0));return this.tokens};var a={escape:/^\\([\\`*{}\[\]()#+\-.!_>])/,autolink:/^<([^ >]+(@|:\/)[^ >]+)>/,url:r,tag:/^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,link:/^!?\[(inside)\]\(href\)/,reflink:/^!?\[(inside)\]\s*\[([^\]]*)\]/,nolink:/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,strong:/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,em:/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,code:/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:r,text:/^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/};a._inside=/(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/,a._href=/\s*<?([^\s]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/,a.link=i(a.link)("inside",a._inside)("href",a._href)(),a.reflink=i(a.reflink)("inside",a._inside)(),a.normal=l({},a),a.pedantic=l({},a.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),a.gfm=l({},a.normal,{escape:i(a.escape)("])","~|])")(),url:/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,del:/^~~(?=\S)([\s\S]*?\S)~~/,text:i(a.text)("]|","~]|")("|","|https?://|")()}),a.breaks=l({},a.gfm,{br:i(a.br)("{2,}","*")(),text:i(a.gfm.text)("{2,}","*")()}),e.rules=a,e.output=function(t,s,n){var i=new e(s,n);return i.output(t)},e.prototype.output=function(t){for(var e,s,i,r,l="";t;)if(r=this.rules.escape.exec(t))t=t.substring(r[0].length),l+=r[1];else if(r=this.rules.autolink.exec(t))t=t.substring(r[0].length),"@"===r[2]?(s=":"===r[1][6]?this.mangle(r[1].substring(7)):this.mangle(r[1]),i=this.mangle("mailto:")+s):(s=n(r[1]),i=s),l+='<a href="'+i+'">'+s+"</a>";else if(r=this.rules.url.exec(t))t=t.substring(r[0].length),s=n(r[1]),i=s,l+='<a href="'+i+'">'+s+"</a>";else if(r=this.rules.tag.exec(t))t=t.substring(r[0].length),l+=this.options.sanitize?n(r[0]):r[0];else if(r=this.rules.link.exec(t))t=t.substring(r[0].length),l+=this.outputLink(r,{href:r[2],title:r[3]});else if((r=this.rules.reflink.exec(t))||(r=this.rules.nolink.exec(t))){if(t=t.substring(r[0].length),e=(r[2]||r[1]).replace(/\s+/g," "),e=this.links[e.toLowerCase()],!e||!e.href){l+=r[0][0],t=r[0].substring(1)+t;continue}l+=this.outputLink(r,e)}else if(r=this.rules.strong.exec(t))t=t.substring(r[0].length),l+="<strong>"+this.output(r[2]||r[1])+"</strong>";else if(r=this.rules.em.exec(t))t=t.substring(r[0].length),l+="<em>"+this.output(r[2]||r[1])+"</em>";else if(r=this.rules.code.exec(t))t=t.substring(r[0].length),l+="<code>"+n(r[2],!0)+"</code>";else if(r=this.rules.br.exec(t))t=t.substring(r[0].length),l+="<br>";else if(r=this.rules.del.exec(t))t=t.substring(r[0].length),l+="<del>"+this.output(r[1])+"</del>";else if(r=this.rules.text.exec(t))t=t.substring(r[0].length),l+=n(r[0]);else if(t)throw Error("Infinite loop on byte: "+t.charCodeAt(0));return l},e.prototype.outputLink=function(t,e){return"!"!==t[0][0]?'<a href="'+n(e.href)+'"'+(e.title?' title="'+n(e.title)+'"':"")+">"+this.output(t[1])+"</a>":'<img src="'+n(e.href)+'" alt="'+n(t[1])+'"'+(e.title?' title="'+n(e.title)+'"':"")+">"},e.prototype.smartypants=function(t){return this.options.smartypants?t.replace(/--/g,"—").replace(/'([^']*)'/g,"‘$1’").replace(/"([^"]*)"/g,"“$1”").replace(/\.{3}/g,"…"):t},e.prototype.mangle=function(t){for(var e,s="",n=t.length,i=0;n>i;i++)e=t.charCodeAt(i),Math.random()>.5&&(e="x"+e.toString(16)),s+="&#"+e+";";return s},s.parse=function(t,e){var n=new s(e);return n.parse(t)},s.prototype.parse=function(t){this.inline=new e(t.links,this.options),this.tokens=t.reverse();for(var s="";this.next();)s+=this.tok();return s},s.prototype.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){for(var t=this.token.text;"text"===this.peek().type;)t+="\n"+this.next().text;return this.inline.output(t)},s.prototype.tok=function(){switch(this.token.type){case"space":return"";case"hr":return"<hr>\n";case"heading":return"<h"+this.token.depth+">"+this.inline.output(this.token.text)+"</h"+this.token.depth+">\n";case"code":if(this.options.highlight){var t=this.options.highlight(this.token.text,this.token.lang);null!=t&&t!==this.token.text&&(this.token.escaped=!0,this.token.text=t)}return this.token.escaped||(this.token.text=n(this.token.text,!0)),"<pre><code"+(this.token.lang?' class="'+this.options.langPrefix+this.token.lang+'"':"")+">"+this.token.text+"</code></pre>\n";case"table":var e,s,i,r,l,o="";for(o+="<thead>\n<tr>\n",s=0;this.token.header.length>s;s++)e=this.inline.output(this.token.header[s]),o+=this.token.align[s]?'<th align="'+this.token.align[s]+'">'+e+"</th>\n":"<th>"+e+"</th>\n";for(o+="</tr>\n</thead>\n",o+="<tbody>\n",s=0;this.token.cells.length>s;s++){for(i=this.token.cells[s],o+="<tr>\n",l=0;i.length>l;l++)r=this.inline.output(i[l]),o+=this.token.align[l]?'<td align="'+this.token.align[l]+'">'+r+"</td>\n":"<td>"+r+"</td>\n";o+="</tr>\n"}return o+="</tbody>\n","<table>\n"+o+"</table>\n";case"blockquote_start":for(var o="";"blockquote_end"!==this.next().type;)o+=this.tok();return"<blockquote>\n"+o+"</blockquote>\n";case"list_start":for(var h=this.token.ordered?"ol":"ul",o="";"list_end"!==this.next().type;)o+=this.tok();return"<"+h+">\n"+o+"</"+h+">\n";case"list_item_start":for(var o="";"list_item_end"!==this.next().type;)o+="text"===this.token.type?this.parseText():this.tok();return"<li>"+o+"</li>\n";case"loose_item_start":for(var o="";"list_item_end"!==this.next().type;)o+=this.tok();return"<li>"+o+"</li>\n";case"html":return this.token.pre||this.options.pedantic?this.token.text:this.inline.output(this.token.text);case"paragraph":return"<p>"+this.inline.output(this.token.text)+"</p>\n";case"text":return"<p>"+this.parseText()+"</p>\n"}},r.exec=r,o.options=o.setOptions=function(t){return l(o.defaults,t),o},o.defaults={gfm:!0,tables:!0,breaks:!1,pedantic:!1,sanitize:!1,smartLists:!1,silent:!1,highlight:null,langPrefix:"lang-"},o.Parser=s,o.parser=s.parse,o.Lexer=t,o.lexer=t.lex,o.InlineLexer=e,o.inlineLexer=e.output,o.parse=o,"object"==typeof exports?module.exports=o:"function"==typeof define&&define.amd?define(function(){return o}):this.marked=o}).call(function(){return this||("undefined"!=typeof window?window:global)}());</script>

<polymer-element name="marked-js" attributes="text" assetpath="../marked-js/">
  <script>
    Polymer('marked-js', {
      text: '',
      attached: function() {
        marked.setOptions({
          highlight: this.highlight.bind(this)
        });
        if (!this.text) {
          this.text = this.innerHTML;
        }
      },
      textChanged: function () {
        this.innerHTML = marked(this.text); //.replace(/^[^\S\n]+/gm,''));
      },
      highlight: function(code, lang) {
        return this.fire('marked-js-highlight', {code: code, lang: lang}).code || code;
      }
    });
  </script>
</polymer-element>











<script>var hljs=new function(){function l(o){return o.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;")}function b(p){for(var o=p.firstChild;o;o=o.nextSibling){if(o.nodeName=="CODE"){return o}if(!(o.nodeType==3&&o.nodeValue.match(/\s+/))){break}}}function h(p,o){return Array.prototype.map.call(p.childNodes,function(q){if(q.nodeType==3){return o?q.nodeValue.replace(/\n/g,""):q.nodeValue}if(q.nodeName=="BR"){return"\n"}return h(q,o)}).join("")}function a(q){var p=(q.className+" "+q.parentNode.className).split(/\s+/);p=p.map(function(r){return r.replace(/^language-/,"")});for(var o=0;o<p.length;o++){if(e[p[o]]||p[o]=="no-highlight"){return p[o]}}}function c(q){var o=[];(function p(r,s){for(var t=r.firstChild;t;t=t.nextSibling){if(t.nodeType==3){s+=t.nodeValue.length}else{if(t.nodeName=="BR"){s+=1}else{if(t.nodeType==1){o.push({event:"start",offset:s,node:t});s=p(t,s);o.push({event:"stop",offset:s,node:t})}}}}return s})(q,0);return o}function j(x,v,w){var p=0;var y="";var r=[];function t(){if(x.length&&v.length){if(x[0].offset!=v[0].offset){return(x[0].offset<v[0].offset)?x:v}else{return v[0].event=="start"?x:v}}else{return x.length?x:v}}function s(A){function z(B){return" "+B.nodeName+'="'+l(B.value)+'"'}return"<"+A.nodeName+Array.prototype.map.call(A.attributes,z).join("")+">"}while(x.length||v.length){var u=t().splice(0,1)[0];y+=l(w.substr(p,u.offset-p));p=u.offset;if(u.event=="start"){y+=s(u.node);r.push(u.node)}else{if(u.event=="stop"){var o,q=r.length;do{q--;o=r[q];y+=("</"+o.nodeName.toLowerCase()+">")}while(o!=u.node);r.splice(q,1);while(q<r.length){y+=s(r[q]);q++}}}}return y+l(w.substr(p))}function f(q){function o(s,r){return RegExp(s,"m"+(q.cI?"i":"")+(r?"g":""))}function p(y,w){if(y.compiled){return}y.compiled=true;var s=[];if(y.k){var r={};function z(A,t){t.split(" ").forEach(function(B){var C=B.split("|");r[C[0]]=[A,C[1]?Number(C[1]):1];s.push(C[0])})}y.lR=o(y.l||hljs.IR,true);if(typeof y.k=="string"){z("keyword",y.k)}else{for(var x in y.k){if(!y.k.hasOwnProperty(x)){continue}z(x,y.k[x])}}y.k=r}if(w){if(y.bWK){y.b="\\b("+s.join("|")+")\\s"}y.bR=o(y.b?y.b:"\\B|\\b");if(!y.e&&!y.eW){y.e="\\B|\\b"}if(y.e){y.eR=o(y.e)}y.tE=y.e||"";if(y.eW&&w.tE){y.tE+=(y.e?"|":"")+w.tE}}if(y.i){y.iR=o(y.i)}if(y.r===undefined){y.r=1}if(!y.c){y.c=[]}for(var v=0;v<y.c.length;v++){if(y.c[v]=="self"){y.c[v]=y}p(y.c[v],y)}if(y.starts){p(y.starts,w)}var u=[];for(var v=0;v<y.c.length;v++){u.push(y.c[v].b)}if(y.tE){u.push(y.tE)}if(y.i){u.push(y.i)}y.t=u.length?o(u.join("|"),true):{exec:function(t){return null}}}p(q)}function d(D,E){function o(r,M){for(var L=0;L<M.c.length;L++){var K=M.c[L].bR.exec(r);if(K&&K.index==0){return M.c[L]}}}function s(K,r){if(K.e&&K.eR.test(r)){return K}if(K.eW){return s(K.parent,r)}}function t(r,K){return K.i&&K.iR.test(r)}function y(L,r){var K=F.cI?r[0].toLowerCase():r[0];return L.k.hasOwnProperty(K)&&L.k[K]}function G(){var K=l(w);if(!A.k){return K}var r="";var N=0;A.lR.lastIndex=0;var L=A.lR.exec(K);while(L){r+=K.substr(N,L.index-N);var M=y(A,L);if(M){v+=M[1];r+='<span class="'+M[0]+'">'+L[0]+"</span>"}else{r+=L[0]}N=A.lR.lastIndex;L=A.lR.exec(K)}return r+K.substr(N)}function z(){if(A.sL&&!e[A.sL]){return l(w)}var r=A.sL?d(A.sL,w):g(w);if(A.r>0){v+=r.keyword_count;B+=r.r}return'<span class="'+r.language+'">'+r.value+"</span>"}function J(){return A.sL!==undefined?z():G()}function I(L,r){var K=L.cN?'<span class="'+L.cN+'">':"";if(L.rB){x+=K;w=""}else{if(L.eB){x+=l(r)+K;w=""}else{x+=K;w=r}}A=Object.create(L,{parent:{value:A}});B+=L.r}function C(K,r){w+=K;if(r===undefined){x+=J();return 0}var L=o(r,A);if(L){x+=J();I(L,r);return L.rB?0:r.length}var M=s(A,r);if(M){if(!(M.rE||M.eE)){w+=r}x+=J();do{if(A.cN){x+="</span>"}A=A.parent}while(A!=M.parent);if(M.eE){x+=l(r)}w="";if(M.starts){I(M.starts,"")}return M.rE?0:r.length}if(t(r,A)){throw"Illegal"}w+=r;return r.length||1}var F=e[D];f(F);var A=F;var w="";var B=0;var v=0;var x="";try{var u,q,p=0;while(true){A.t.lastIndex=p;u=A.t.exec(E);if(!u){break}q=C(E.substr(p,u.index-p),u[0]);p=u.index+q}C(E.substr(p));return{r:B,keyword_count:v,value:x,language:D}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:l(E)}}else{throw H}}}function g(s){var o={keyword_count:0,r:0,value:l(s)};var q=o;for(var p in e){if(!e.hasOwnProperty(p)){continue}var r=d(p,s);r.language=p;if(r.keyword_count+r.r>q.keyword_count+q.r){q=r}if(r.keyword_count+r.r>o.keyword_count+o.r){q=o;o=r}}if(q.language){o.second_best=q}return o}function i(q,p,o){if(p){q=q.replace(/^((<[^>]+>|\t)+)/gm,function(r,v,u,t){return v.replace(/\t/g,p)})}if(o){q=q.replace(/\n/g,"<br>")}return q}function m(r,u,p){var v=h(r,p);var t=a(r);if(t=="no-highlight"){return}var w=t?d(t,v):g(v);t=w.language;var o=c(r);if(o.length){var q=document.createElement("pre");q.innerHTML=w.value;w.value=j(o,c(q),v)}w.value=i(w.value,u,p);var s=r.className;if(!s.match("(\\s|^)(language-)?"+t+"(\\s|$)")){s=s?(s+" "+t):t}r.innerHTML=w.value;r.className=s;r.result={language:t,kw:w.keyword_count,re:w.r};if(w.second_best){r.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function n(){if(n.called){return}n.called=true;Array.prototype.map.call(document.getElementsByTagName("pre"),b).filter(Boolean).forEach(function(o){m(o,hljs.tabReplace)})}function k(){window.addEventListener("DOMContentLoaded",n,false);window.addEventListener("load",n,false)}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=m;this.initHighlighting=n;this.initHighlightingOnLoad=k;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\[\\s\\S]",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(q,r){var o={};for(var p in q){o[p]=q[p]}if(r){for(var p in r){o[p]=r[p]}}return o}}();hljs.LANGUAGES.javascript=function(a){return{k:{keyword:"in if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const",literal:"true false null undefined NaN Infinity"},c:[a.ASM,a.QSM,a.CLCM,a.CBLCLM,a.CNM,{b:"("+a.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[a.CLCM,a.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",i:"\\n",c:[{b:"\\\\/"}]},{b:"<",e:">;",sL:"xml"}],r:0},{cN:"function",bWK:true,e:"{",k:"function",c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[a.CLCM,a.CBLCLM],i:"[\"'\\(]"}],i:"\\[|%"}]}}(hljs);hljs.LANGUAGES.css=function(a){var b={cN:"function",b:a.IR+"\\(",e:"\\)",c:[a.NM,a.ASM,a.QSM]};return{cI:true,i:"[=/|']",c:[a.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:"import page media charset",c:[b,a.ASM,a.QSM,a.NM]},{cN:"tag",b:a.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[a.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[b,a.NM,a.QSM,a.ASM,a.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}(hljs);hljs.LANGUAGES.xml=function(a){var c="[A-Za-z0-9\\._:-]+";var b={eW:true,c:[{cN:"attribute",b:c,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{title:"style"},c:[b],starts:{e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{title:"script"},c:[b],starts:{e:"<\/script>",rE:true,sL:"javascript"}},{b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},b]}]}}(hljs);hljs.LANGUAGES.python=function(a){var f={cN:"prompt",b:"^(>>>|\\.\\.\\.) "};var c=[{cN:"string",b:"(u|b)?r?'''",e:"'''",c:[f],r:10},{cN:"string",b:'(u|b)?r?"""',e:'"""',c:[f],r:10},{cN:"string",b:"(u|r|ur)'",e:"'",c:[a.BE],r:10},{cN:"string",b:'(u|r|ur)"',e:'"',c:[a.BE],r:10},{cN:"string",b:"(b|br)'",e:"'",c:[a.BE]},{cN:"string",b:'(b|br)"',e:'"',c:[a.BE]}].concat([a.ASM,a.QSM]);var e={cN:"title",b:a.UIR};var d={cN:"params",b:"\\(",e:"\\)",c:["self",a.CNM,f].concat(c)};var b={bWK:true,e:":",i:"[${=;\\n]",c:[e,d],r:10};return{k:{keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda nonlocal|10",built_in:"None True False Ellipsis NotImplemented"},i:"(</|->|\\?)",c:c.concat([f,a.HCM,a.inherit(b,{cN:"function",k:"def"}),a.inherit(b,{cN:"class",k:"class"}),a.CNM,{cN:"decorator",b:"@",e:"$"},{b:"\\b(print|exec)\\("}])}}(hljs);</script>


<!--

Displays YUIDoc formatted source documentation scraped from input urls.

@class polymer-doc-viewer
-->
<polymer-element name="polymer-doc-viewer" attributes="url href sources" assetpath="../polymer-doc-viewer/">
<!--

Set url to add documentation from that location to the view.

@attribute url
@type String
-->

  <template>

    <context-free-parser url="{{url}}" on-data-ready="{{parserDataReady}}"></context-free-parser>
    <template repeat="{{sources}}">
      <context-free-parser url="{{}}" on-data-ready="{{parserDataReady}}"></context-free-parser>
    </template>

    <style>/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>

*/

pre code {
  display: block; padding: 0.5em;
  background: #F0F0F0;
}

pre code,
pre .subst,
pre .tag .title,
pre .lisp .title,
pre .clojure .built_in,
pre .nginx .title {
  color: black;
}

pre .string,
pre .title,
pre .constant,
pre .parent,
pre .tag .value,
pre .rules .value,
pre .rules .value .number,
pre .preprocessor,
pre .ruby .symbol,
pre .ruby .symbol .string,
pre .aggregate,
pre .template_tag,
pre .django .variable,
pre .smalltalk .class,
pre .addition,
pre .flow,
pre .stream,
pre .bash .variable,
pre .apache .tag,
pre .apache .cbracket,
pre .tex .command,
pre .tex .special,
pre .erlang_repl .function_or_atom,
pre .markdown .header {
  color: #800;
}

pre .comment,
pre .annotation,
pre .template_comment,
pre .diff .header,
pre .chunk,
pre .markdown .blockquote {
  color: #888;
}

pre .number,
pre .date,
pre .regexp,
pre .literal,
pre .smalltalk .symbol,
pre .smalltalk .char,
pre .go .constant,
pre .change,
pre .markdown .bullet,
pre .markdown .link_url {
  color: #080;
}

pre .label,
pre .javadoc,
pre .ruby .string,
pre .decorator,
pre .filter .argument,
pre .localvars,
pre .array,
pre .attr_selector,
pre .important,
pre .pseudo,
pre .pi,
pre .doctype,
pre .deletion,
pre .envvar,
pre .shebang,
pre .apache .sqbracket,
pre .nginx .built_in,
pre .tex .formula,
pre .erlang_repl .reserved,
pre .prompt,
pre .markdown .link_label,
pre .vhdl .attribute,
pre .clojure .attribute,
pre .coffeescript .property {
  color: #88F
}

pre .keyword,
pre .id,
pre .phpdoc,
pre .title,
pre .built_in,
pre .aggregate,
pre .css .tag,
pre .javadoctag,
pre .phpdoc,
pre .yardoctag,
pre .smalltalk .class,
pre .winutils,
pre .bash .variable,
pre .apache .tag,
pre .go .typename,
pre .tex .command,
pre .markdown .strong,
pre .request,
pre .status {
  font-weight: bold;
}

pre .markdown .emphasis {
  font-style: italic;
}

pre .nginx .built_in {
  font-weight: normal;
}

pre .coffeescript .javascript,
pre .javascript .xml,
pre .tex .formula,
pre .xml .javascript,
pre .xml .vbscript,
pre .xml .css,
pre .xml .cdata {
  opacity: 0.5;
}
</style>
    <style>:host {
  display: block;
  /*height: 100%;*/
}

div {
  display: block;
}

.element {
  font-size: 21px;
}

.name {
  /* typography */
  color: white;
  /* font-size: 14px; */
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;
  /* colors / effects */
  background-color: #999;
  box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1);
  box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
  border-radius: 2px;
  cursor: pointer;
  /* metrics */
  display: inline-block;
  padding: 4px 12px 5px 12px;
  margin: 4px 0;
  /*padding: 0.35em 1em;
  margin: 0.3em 0;*/
}

.method {
  background-color: #0F9D58;
}

.event {
  background-color: #F4B400;
}

.nattribute {
  background-color: #4285F4;
  border-radius: 2px 0 0 2px;
}

.type {
  background-color: white;
  border: 1px solid #4285F4;
  color: #4285F4;
  font-weight: bold;
  border-radius: 0 2px 2px 0;
  padding-top: 3px;
  padding-bottom: 4px;
}

.header {
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-left: none;
  border-right: none;
  padding: 0 16px;
  line-height: 75px;
}

.ntitle {
  font-size: 13px;
  font-weight: bold;
  margin: 8px 0;
}

.box {
  margin-bottom: 40px;
}

pre code {
  font-size: 14px;
  padding: 12px 13px;
  max-width: 800px;
  white-space: pre-wrap;
  overflow: hidden;
}

a {
  color: #666;
  text-decoration: none;
}

.summary {
  width: 240px; 
  padding: 16px;
}

@media (max-width: 900px) {
  .summary {
    display: none;
  }
}

#menu {
  width: 280px;
}

#docs {
  overflow-x: auto;
  background-color: white;
}

#docsInner {
  min-width: 500px;
}

#fixed {
  position: fixed;
  opacity: 0.95;
  right: 24px;
  left: 296px;
  background-color: white;
  z-index: 1000;
  display: none;
}

.animate {
  -webkit-transition-property: left, top, width, height;
  -webkit-transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
}
</style>

    <polymer-grid-layout id="grid" on-polymer-grid-layout="{{gridLayout}}"></polymer-grid-layout>

    <div id="navigation" offscreen="basement" style="overflow-y: scroll;">

      <polymer-ui-menu selected="0" id="menu">

        <template repeat="{{classes}}">
          <polymer-ui-menu-item><a href="#{{name}}">{{name}}</a></polymer-ui-menu-item>
        </template>

      </polymer-ui-menu>

    </div>

    <div id="docs" flex="" on-marked-js-highlight="{{hilight}}" on-scroll="{{docsScroll}}">
      <div id="docsInner" flex="">
        <div id="fixed">
          <div class="header">

            <polymer-ui-icon-button icon="menu" on-tap="{{toggleNav}}" active="{{navOpen}}"></polymer-ui-icon-button>
            &nbsp;<span id="fixedTopic" class="element"></span>

          </div>
        </div>

        <template repeat="{{class in classes}}">

          <a id="{{class.name}}" class="element"></a>

          <div class="header topic">
            <polymer-ui-icon-button on-tap="{{toggleLayout}}" icon="menu" style="visibility: hidden;"></polymer-ui-icon-button>
            &nbsp;<span class="element">{{class.name}}</span>
          </div>
  
          <div>
            <polymer-flex-layout></polymer-flex-layout>

            <div class="summary">

              <template if="{{class.methods.length}}">
                <section class="box">
                  <div class="ntitle">Methods</div>
                  <template repeat="{{class.methods}}">
                    <span class="name method">{{name}}</span><br>
                  </template>
                </section>
              </template>

              <template if="{{class.attributes.length}}">
                <section class="box">
                  <div class="ntitle">Attributes</div>
                  <template repeat="{{class.attributes}}">
                    <span class="name nattribute">{{name}}</span><br>
                  </template>
                </section>
              </template>

              <template if="{{class.events.length}}">
                <section class="box">
                  <div class="ntitle">Events</div>
                  <template repeat="{{class.events}}">
                    <span class="name event">{{name}}</span><br>
                  </template>
                </section>
              </template>

            </div>

            <div flex="">
              <div style="padding: 16px;">

                <!--<section class="box">
                  Module<br>
                  <span class="name">{{class.module}}</span>
                </section>-->

                <template if="{{class.description}}">
                  <section class="box">
                    <div class="ntitle">Description</div>
                    <marked-js text="{{class.description}}"></marked-js>
                  </section>
                </template>

                <template if="{{class.methods.length}}">
                  <section class="box">
                    <div class="ntitle">Methods</div>
                    <template repeat="{{class.methods}}">
                      <span class="name method">{{name}}</span>
                      <marked-js text="{{description}}"></marked-js>
                    </template>
                  </section>
                </template>

                <template if="{{class.attributes.length}}">
                  <section class="box">
                    <div class="ntitle">Attributes</div>
                    <template repeat="{{class.attributes}}">
                      <span class="name nattribute">{{name}}</span><span class="name type">{{type}}</span>
                      <marked-js text="{{description}}"></marked-js>
                      <br>
                    </template>
                  </section>
                </template>

                <template if="{{class.events.length}}">
                  <section class="box">
                    <div class="ntitle">Events</div>
                    <template repeat="{{class.events}}">
                      <span class="name event">{{name}}</span>
                      <marked-js text="{{description}}"></marked-js>
                      <br>
                    </template>
                  </section>
                </template>

              </div>
            </div>
          </div>
        </template>

        <hr>
        <div style="height: 1024px"></div>

      </div>
    </div>
  </template>
  <script>
    Polymer('polymer-doc-viewer', {
      sources: [],
      data: null,
      route: '',
      layouts: {
        open: [
          [1, 2, 2]
        ],
        closed: [
          [2, 2]
        ],
      },
      navOpen: true,
      ready: function() {
        this.classes = [];
        // TODO(sjmiles): manual because flatiron-director didn't work, find out why
        window.addEventListener('hashchange', this.parseLocationHash.bind(this));
        this.parseLocationHash();
        // TODO(sjmiles): improve method of configuring grid
        this.$.grid.nodes = [this.$.navigation, this.$.docs];
        this.$.grid.layout = this.layouts.open;
      },
      onMutation: function(node, listener) {
        var observer = new MutationObserver(function() {
          listener.call(this, observer);
          observer.disconnect();
        }.bind(this));
        observer.observe(node, {childList: true, subtree: true});
      },
      parseLocationHash: function() {
        this.route = window.location.hash.slice(1);
      },
      gridLayout: function() {
        // TODO(sjmiles): the 'fixed' header bar is relative to the screen
        // to position it dynamically we need to know offsetLeft of the
        // docs panel after the first layout.
        if (!this.fixedLeft) {
          this.fixedLeft = this.$.docs.offsetLeft;
          this.$.fixed.style.display = 'block';
          this.effectLayout();
        }
        this.$.docs.classList.add('animate');
        this.$.fixed.classList.add('animate');
      },
      hilight: function(event, detail, sender) {
        detail.code = hljs.highlightAuto(detail.code).value;
      },
      docsNodeChanged: function(observer) {
        this.docsScroll();
      },
      docsScroll: function() {
        var t = this.$.docs.scrollTop + 80;
        var hcs = this.$.docsInner.querySelectorAll('.topic');
        for (var i = 0, hc; hc = hcs[i]; i++) {
          if (t >= hc.offsetTop && (!hcs[i+1] || t < hcs[i+1].offsetTop)) {
            var h = hc.querySelector('.element');
            if (h) {
              this.$.fixedTopic.innerText = h.innerText;	
            }
            return;
          }
        }
      },
      routeChanged: function() {
        var anchor = this.shadowRoot.querySelector('a[id="' + this.route + '"]');
        if (anchor) {
          anchor.scrollIntoView();
        }
      },
      toggleNav: function(event, detail, sender) {
        // TODO(sjmiles): would be nice to automate this common action
        this.navOpen = !this.navOpen;
      },
      navOpenChanged: function() {
        // TODO(sjmiles): would be nice to automate this common action
        this.effectLayout();
      },
      effectLayout: function() {
        this.$.grid.layout = this.navOpen ? this.layouts.open : this.layouts.closed;
        this.$.fixed.style.left = this.navOpen ? this.fixedLeft + 'px' : '0px';
      },
      parserDataReady: function(event) {
        this.onMutation(this.$.docs, this.docsNodeChanged);
        this.classes = this.classes.concat(event.target.data.classes);
      },
      dataChanged: function() {
        // neccesary data structure:
        //  classes: [{ 
        //    name: String,
        //    attributes: [
        //    ],
        //    events: [
        //    ],
        //    methods: [
        //    ]
        //  }, ...]
        
        // schedule more work when changes here propagate to DOM
        this.onMutation(this.$.docs, this.docsNodeChanged);
        this.classes = this.classes.concat(this.data.classes);
      }
    });
  </script>
</polymer-element>
<polymer-element name="polymer-home-page" assetpath="../polymer-home-page-dev/">
  <template>
    <style>﻿:host {
  white-space: nowrap;
  overflow: hidden;
  position: relative;
  display: block;
}

h2 {
  display: inline-block;
  margin: 8px 6px;
  vertical-align: middle;
}

.choiceB, .choiceC, .choiceD {
  /* typography */
  color: white;
  /* font-size: 14px; */
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;
  /* colors / effects */
  background-color: #4285F4;
  box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1);
  box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
  border-radius: 2px;
  cursor: pointer;
  /* metrics */
  display: inline-block;
  padding: 4px 12px 5px 12px;
  margin: 4px 0;
  /*padding: 0.35em 1em;
  margin: 0.3em 0;*/
}

/*.choiceB, .choiceC, .choiceD {
  font-size: 0.8em;
  display: inline-block;
  white-space: nowrap;
  padding: 2px 16px;
  vertical-align: middle;
  margin-top: 3px;
  text-align: center;
  text-transform: uppercase;
  color: #eee;
  border-radius: 23px;
  text-decoration: none;
}

.choiceB {
  background-color: #BF8A30;
}

.choiceB:hover {
  background-color: #C7F83E;
  color: #222;
}

.choiceC {
  background-color: #284B7E;
}

.choiceC:hover {
  background-color: #C7F83E;
  color: #222;
}

.choiceD {
  background-color: #4B287E;
}

.choiceD:hover {
  background-color: #F8C73E;
  color: #222;
}
*/

polymer-doc-viewer {
  display: block;
  position: absolute;
  top: 50px;
  right: 0;
  bottom: 0px;
  left: 0;
  border: 1px solid silver;
}
</style>
    <h2>{{moduleName}}</h2>
    <a class="choiceC" target="_blank" href="../{{moduleName}}/demo.html">demo</a>
    <a class="choiceB" target="_blank" href="../../designer/?element={{moduleName}}">sandbox</a>
    <a class="choiceD" target="_blank" href="../polymer-home-page-dev/fail.html">install</a>
    <polymer-doc-viewer url="{{moduleName}}.html"></polymer-doc-viewer>
  </template>
  <script>
    Polymer('polymer-home-page', {
      ready: function() {
        var path = location.pathname.split('/');
        var name = path.pop() || path.pop();
        if (name.indexOf('.html') >= 0) {
          name = path.pop();
        }
        document.querySelector('title').textContent = name;
        this.moduleName = name;
      }
    });
  </script>
</polymer-element>
